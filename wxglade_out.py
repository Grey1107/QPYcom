#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.9.6 on Sat Sep 26 08:32:20 2020
#

# imports
# sys
import os
import sys
import math
# gui
import wx
from wx.lib import sized_controls

# utils
import time
import datetime
import threading
import fileinput
#import psutil
import shutil
import tempfile
import locale
import glob

import uuid
import paho.mqtt.client as mqtt


# message (pypubsub)
from pubsub import pub

# serial (pyserial)
import serial
import serial.tools.list_ports
ser = serial.Serial()

# config file
import configparser

# file utils
from fileIO import *

# platform info
import platform

# for str proc
import re

#for block Chinese input
import string
# for nothing
import random

# for autoupdate json process
from json_process import *
versionGlobal = "1.4"
## SLOBODAN ##

# JSON
import json
import codecs

# for subprocesses
import subprocess
import webbrowser
# reading from the serial port - unstring
from ast import literal_eval

serPort = serial.tools.list_ports
# backup file check
listCheck= {}
listCheck_backup = {}

# PriorityQueue 
from queue import PriorityQueue

# il8n support
import gettext
# DPI Awareness
import ctypes
'''
# Query DPI Awareness (Windows 10 and 8)
awareness = ctypes.c_int()
errorCode = ctypes.windll.shcore.GetProcessDpiAwareness(0, ctypes.byref(awareness))
# print(awareness.value)
# Set DPI Awareness  (Windows 10 and 8)
errorCode = ctypes.windll.shcore.SetProcessDpiAwareness(2)
# the argument is the awareness level, which can be 0, 1 or 2:
# for 1-to-1 pixel control I seem to need it to be non-zero (I'm using level 2)
# Set DPI Awareness  (Windows 7 and Vista)
success = ctypes.windll.user32.SetProcessDPIAware()
'''
# serial vars
# can not change serial port setting
serialStatus = False
serialList = []
fw_versionFlag = True # The default is a dual file system
# serial recv data
num = 0
#  module file max size  --5mb
maxFileSize = 5242880
# Dynamic module file size for file tab
availableSpaceFile = 5242880
# filesize for module now
nowTotalFileSize = 0
# fw download timeMonitoring
timeMonitor = 0	
# protectFile can't be delete
protectFile = ["apn_cfg.json"]
# some software vars
PROJECT_ABSOLUTE_PATH = os.path.dirname(os.path.abspath(__file__))
# start time
PROJECT_START_TIMESTAMP = time.time()
# IP information obtained when opened
dict_last = {}
# init ontop flag
ontopFlag = True
# Configured editor app for download tab
conf_editor = ''


# logging helper globals
open_time = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
# open_time = "onlyfor_test_20200322_date_night"
#keycode dict
keycodeLastlineWhiteList = {	'WXK_LEFT': 314, 'WXK_UP': 315, 'WXK_RIGHT': 316, 'WXK_DOWN': 317,
								'WXK_NUMPAD_LEFT': 376, 'WXK_NUMPAD_UP': 377, 'WXK_NUMPAD_RIGHT': 378, 'WXK_NUMPAD_DOWN': 379,
								'WXK_PAGEUP': 366, 'WXK_PAGEDOWN': 367, 'WXK_END': 312, 'WXK_HOME': 313,
								'WXK_NUMPAD_HOME': 375, 'WXK_NUMPAD_PAGEUP': 380, 'WXK_NUMPAD_PAGEDOWN': 381, 'WXK_NUMPAD_END': 382,
								'WXK_SHIFT': 306, 'WXK_CONTROL': 308, 'WXK_INSERT': 322, 'WXK_NUMPAD_INSERT': 384,
								'WXK_DELETE': 127, 'WXK_NUMPAD_DELETE': 385, 'WXK_BACK': 8, 'WXK_NUMPAD_ENTER': 370, 'WXK_RETURN': 13,
								'WXK_WINDOWS_MENU': 395, 'WXK_WINDOWS_LEFT': 393, 'WXK_WINDOWS_RIGHT': 394,
								'WXK_ALT': 307, 'WXK_ESCAPE': 27}
keycodeOtherLineWhiteList = {	'WXK_LEFT': 314, 'WXK_UP': 315, 'WXK_RIGHT': 316, 'WXK_DOWN': 317,
								'WXK_NUMPAD_LEFT': 376, 'WXK_NUMPAD_UP': 377, 'WXK_NUMPAD_RIGHT': 378, 'WXK_NUMPAD_DOWN': 379,
								'WXK_PAGEUP': 366, 'WXK_PAGEDOWN': 367, 'WXK_END': 312, 'WXK_HOME': 313,
								'WXK_NUMPAD_HOME': 375, 'WXK_NUMPAD_PAGEUP': 380, 'WXK_NUMPAD_PAGEDOWN': 381, 'WXK_NUMPAD_END': 382,
								'WXK_SHIFT': 306, 'WXK_CONTROL': 308, 'WXK_INSERT': 322, 'WXK_NUMPAD_INSERT': 384,
								'WXK_WINDOWS_LEFT': 393, 'WXK_WINDOWS_RIGHT': 394, 'WXK_ALT': 307, 'WXK_ESCAPE': 27}
keycodeLastlineCtrlWordWhiteList = {'WXK_LEFT': 314, 'WXK_UP': 315, 'WXK_RIGHT': 316, 'WXK_DOWN': 317,
									'WXK_NUMPAD_LEFT': 376, 'WXK_NUMPAD_UP': 377, 'WXK_NUMPAD_RIGHT': 378, 'WXK_NUMPAD_DOWN': 379,
									'WXK_PAGEUP': 366, 'WXK_PAGEDOWN': 367, 'WXK_END': 312, 'WXK_HOME': 313,
									'WXK_NUMPAD_HOME': 375, 'WXK_NUMPAD_PAGEUP': 380, 'WXK_NUMPAD_PAGEDOWN': 381, 'WXK_NUMPAD_END': 382,
									'WXK_SHIFT': 306, 'WXK_CONTROL': 308, 'WXK_INSERT': 322, 'WXK_NUMPAD_INSERT': 384,
									'WXK_WINDOWS_MENU': 395, 'WXK_WINDOWS_LEFT': 393, 'WXK_WINDOWS_RIGHT': 394,
									'WXK_ALT': 307, 'WXK_ESCAPE': 27}
keycodeNumber = {	'WXK_NUMPAD0': 324, 'WXK_NUMPAD1': 325, 'WXK_NUMPAD2': 326, 'WXK_NUMPAD3': 327, 'WXK_NUMPAD4': 328,
					'WXK_NUMPAD5': 329, 'WXK_NUMPAD6': 330, 'WXK_NUMPAD7': 331, 'WXK_NUMPAD8': 332, 'WXK_NUMPAD9': 333,
					'0':48, '1':49, '2':50, '3':51, '4':52, '5':53, '6':54, '7':55, '8':56, '9':57}
keycodeCtrl = {	'WXK_LEFT': 314, 'WXK_UP': 315, 'WXK_RIGHT': 316, 'WXK_DOWN': 317,
				'WXK_NUMPAD_LEFT': 376, 'WXK_NUMPAD_UP': 377, 'WXK_NUMPAD_RIGHT': 378, 'WXK_NUMPAD_DOWN': 379,
				'WXK_END': 312, 'WXK_HOME': 313, 'WXK_NUMPAD_HOME': 375, 'WXK_NUMPAD_END': 382,
				'WXK_DELETE': 127, 'WXK_NUMPAD_DELETE': 385, 'WXK_BACK': 8}
keyTabCode = {'WXK_TAB': 9}

# for serial vars
serProcessing = False	# have some opeation need to process?
serProceOnce = False	# has proceed(current loop. maybe need multi loop for walk dir)
serProctype = ""		# ls: list file operation; downloadFile:downloadFile to mod
serProcTmpVar = None	# store some var, like current file path
serLastRecvData = b""	# serial last receive data (str)
serLastRecvTime = 0		# serial last receive data timestamp
serProPathStr = ""
localFilePathStr = ""
statusBarStr = ""		#statusbar text, if not "" then display it, else display "ready"
statusBarStrStatic = ""

disconnectedStatus = None	# connection break  ##PETAR	
flag_download_start = None
flag_download_finished = None
flag_download_failed = None
flag_script_download_failed = None
# flag_block_download = None

# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
from wx import stc
import keyword
# end wxGlade

# statusBar display queue
class statusQueue():
	def __init__(self):
		self.queue = PriorityQueue()
		
	def queue_get(self):
		global statusBarStrStatic
		while True:
			if self.queue.qsize() > 0:			
				i = self.queue.get()			
				statusBarStrStatic = i[1]				
				time.sleep(i[2]/10)			
			else:
				statusBarStrStatic = ""
				time.sleep(0.2)
				

	def queue_put(self,priority, Str, second):
		self.queue.put((priority, Str, second))
		# print(self.queue.qsize())
		return
	def queue_tack_done(self):
		self.queue.task_done()
		return

class treeDrop(wx.TextDropTarget): #A predefined drop target for dealing with text data.
	def __init__(self, object):
		wx.TextDropTarget.__init__(self)
		self.object = object

	def OnDropText(self, x, y, data):
		global ser, serProcessing, serProctype, serProceOnce, serProcTmpVar, serLastRecvData, serLastRecvTime, nowTotalFileSize, serProPathStr

		if ser.isOpen()==False:
			wx.MessageBox(_(u'请先打开串口'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			return None
			
		if serProceOnce==True:
			wx.MessageBox(_(u'正在执行其他操作，请稍后再试'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		else:

			#print("treedrop", data)	#treedrop lua53.dll
			#print("treedrop.fullpath", localFilePathStr + data)	#treedrop c:\lua53.dll
			try:
				id, flag = self.object.HitTest((x, y))
				text = self.object.GetItemText(id)
				
				#print(id, flag, text)	#<wx._core.TreeItemId object at 0x0000018AF2B3A9D8> 128 新建8.txt
				self.object.SetItemDropHighlight(id, True)
				# print(x, y)
				# todo 1.hover to expand tree  2.sub dir support
				if ifExist(localFilePathStr + data):
					if isFile(localFilePathStr + data):
						if fileReadAccesPremission(localFilePathStr + data):
							if getFileSize(localFilePathStr + data) < maxFileSize - nowTotalFileSize:
								item, cookie = self.object.GetFirstChild(id)
								#print(item, cookie)
								if item.IsOk(): #Returns True if this instance is referencing a valid tree item.
									pathStr = self.object.GetItemText(id)
									#print(pathStr)
									# Gets the absolute path based on the current itemID
									if id == self.object.GetRootItem():
										pathStr = ""								
									else:
										while True:
											id = self.object.GetItemParent(id)
											if id == self.object.GetRootItem():
												break
											pathStr = self.object.GetItemText(id)+ "/" + pathStr
									serProcessing = True
									serProctype = "downloadFile"
									serProceOnce = False
									serProcTmpVar = localFilePathStr + data
									serProPathStr = pathStr
								else:
									# wx.MessageBox(_(u'请选择正确的文件夹'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
									serProcessing = True
									serProctype = "downloadFile"
									serProceOnce = False
									serProcTmpVar = localFilePathStr + data
									serProPathStr = ""
							else:
								free_mem = (maxFileSize - nowTotalFileSize) / 1024
								free_kb = math.floor(free_mem)
								err_msg = _(u'空间不足！可用空间 ') + str(free_kb) + '[kB]'
								wx.MessageBox(err_msg, 'Warning', wx.OK | wx.ICON_ERROR)
						else:
							wx.MessageBox(_(u'文件读取失败，请确认是否有读取权限'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
					else:
						wx.MessageBox(_(u'不可拖动文件夹，仅可拖动单个文件。'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				else:
					wx.MessageBox(_(u'源文件/文件夹不存在，请重试'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				
			
				#print(self.object.GetItemText(self.object.GetItemParent(id)))
				# print(Mywin.getItemPathList(self, id, self.object, True))
				# print(Mywin.getItemPathList(self, id, self.object))
				# self.object.InsertItem(0, data)
				# self.SetItemDropHighlight(self.object)
			except:
				wx.MessageBox(_(u'错误的目标'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			#print(self.getItemPathList(self, id, self.object))
			self.object.SetItemDropHighlight(id, False)
			
			return True
			
# Get tool usage information
class getUsageInfo(threading.Thread):
	def __init__(self,dict):
		threading.Thread.__init__(self)
		self.dict = dict
		self.getInfoDict = {}
		self.start()
		
	def run(self):
		global dict_last
		# Motherboard serial number
		# get uuid
		uuid_info = uuid.uuid3(uuid.NAMESPACE_DNS, str(platform.node()))
		# get localtime
		localtime_info = time.strftime('%Y-%m-%d-%H-%M-%S', time.localtime(time.time()))
		if self.dict.get("trigger") == 0:
			self.getInfoDict = {"uuid": str(uuid_info),"localtime": localtime_info}
			self.getInfoDict.update({"local_ip": get_local_ip(), "public_ip": get_public_ip(),"windows_version": get_platform_info()})
			dict_last = self.getInfoDict
			
		else:
			#print(dict_last)
			dict_last.update({"uuid": str(uuid_info),"localtime": localtime_info})
			self.getInfoDict = dict_last
		self.getInfoDict.update(self.dict)
		#return(json.dumps(self.getInfoDict))
		mqtt_send_info = mqttBroker(str(uuid_info),json.dumps(self.getInfoDict))
		#print(self.getInfoDict)

		return

class mqttBroker(threading.Thread):
	def __init__(self,uuid_info,json_info):
		threading.Thread.__init__(self)
		self.uuid = uuid_info
		self.json = json_info
		self.start()
		
	def run(self):
		client = mqtt.Client()
		HOST = "broker.hivemq.com"
		client.connect(HOST, 1883, 60)
		#client.subscribe("quectel/quecpython/QPYcom/static/" + self.uuid)
		client.publish("quectel/quecpython/QPYcom/static/" + self.uuid,self.json,qos=2)
		#client.loop_forever()
		#client.loop_start()
		time.sleep(0.1)
		client.disconnect()
		# print("-------------------------------")
		return
	
## SLOBODAN ##

class MyEventHandler(wx.PyEvtHandler):
	def __init__(self, target):
		self.target = target
		wx.EvtHandler.__init__(self)

	def ProcessEvent(self,event):
		global listCheck, listCheck_backup
		try:
			if self.target.GetColumnsOrder() != [0, 1, 2, 3]:
				self.target.SetColumnsOrder([0, 1, 2, 3])
		except Exception as e:
			print("RuntimeError: ", e)
		# there must be a better way of getting the event type,
		# but I couldn't find it
		if event.GetEventType() == wx.EVT_LEFT_DOWN.evtType[0]:
			#print("Got Mouse Down event")
			(item, where) = self.target.HitTest(event.GetPosition())
			if item != -1:
				#print(wx.GetMousePosition())
				#print(self.target.GetScreenPosition())
				#O◉🔲🔳⚪🔘
				m_x, m_y = wx.GetMousePosition()
				l_x, l_y = self.target.GetScreenPosition()
				col1_sel = m_x<=l_x+self.target.GetColumnWidth(0)
				col1_sel_backup = l_x+self.target.GetColumnWidth(0)<=m_x<=l_x+2*self.target.GetColumnWidth(0)
				if col1_sel:
					if self.target.GetItemText(item, 0)!="⚪":
						self.target.SetItem(item, 0 ,"⚪")
						listCheck[item]=False
					else:
						self.target.SetItem(item, 0, "🔘")
						listCheck[item]=True
					return True
				if col1_sel_backup:
					if self.target.GetItemText(item, 1)!="⚪":
						self.target.SetItem(item, 1 ,"⚪")
						listCheck_backup[item]=False
					else:
						self.target.SetItem(item, 1, "🔘")
						listCheck_backup[item]=True
					return True
				else:
					print("please click first column")
					# self.target.Select(item)
					return False
		# Open Editor from File list in Download notebook
		elif event.GetEventType() == wx.EVT_RIGHT_DOWN.evtType[0]:
			(item, where) = self.target.HitTest(event.GetPosition())
			file_path = self.target.GetItemText(item, 2)

			config = configparser.ConfigParser(interpolation=None)
			cfg_path = PROJECT_ABSOLUTE_PATH + "\\config.ini"
			config.read(cfg_path)

			app_target = config.get('software', 'codeeditorpath')
			app_path = app_target
			raw_file_path = r'%s' %file_path
			raw_app_path = r'%s' %app_path
			self.target.PopupMenu(EditFilePopup(self, raw_file_path, raw_app_path))
			
			return True
		else:
			return False

# The class which handles with a serial port, e.g. open, close, and send commands via serial port
class QuecPort(object):
	def __init__(self, port):
		self._port = port
		self._baudrate=115200
		self._conn = None	

	def OpenConn(self):
		try:
			self._conn = serial.Serial(self._port, self._baudrate)
			return self._conn
		except:
			print("Failed to open port %s " % str(self._port))

	def CloseConn(self):
		self._conn.close()

	def SendCmd(self, cmd):
		self._conn.write((cmd + '\r\n').encode())
		
	def RecvCmd(self):
		return self._conn.read(20)
	
	# PETAR
	def RecvCmdUntil(self):
		time.sleep(0.1)
		try:
			num = self._conn.inWaiting()
			try:
				# res = self._conn.read_until(b"end=1\r\n")
				print(num)
				res = self._conn.read(num)
				return res			
			except:
				return b""
		except:
			print("Failed to open port %s " % str(self._port))
		
class runSubprocess:
	def __init__(self, cmd):
		self.cmd = cmd

	def runner(self):
		realCMD = " ".join(self.cmd)
		realCMD = PROJECT_ABSOLUTE_PATH + "\\" + realCMD.replace("/","\\")
		print(realCMD)
		p = subprocess.Popen(realCMD, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		return p

class runCommand(threading.Thread):
	def __init__(self, cmd, string):
		threading.Thread.__init__(self)
		self.cmd = cmd
		self.string = string
		self.start()

	def run(self):
		global timeMonitor,statusBarStr
		#realCMD = " ".join(self.cmd)
		#realCMD = PROJECT_ABSOLUTE_PATH + "\\" + realCMD.replace("/","\\")
		p = subprocess.Popen(self.cmd,shell=True,stdin=subprocess.PIPE,stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		if self.string == "Downloading...":
			i = 1
			for line in p.stdout:
				print(line.decode(encoding = 'utf-8', errors='ignore'))
				if self.string in line.decode(encoding = 'utf-8', errors='ignore'):
					pub.sendMessage('updateProgress', arg1=str(i*10))
					timeMonitor = str(i*10)
					i += 1
				if "DownLoad Passed" in line.decode(encoding = 'utf-8', errors='ignore'):
					timeMonitor = '100'
					pub.sendMessage('updateProgress', arg1='100')
					p = subprocess.Popen(r'taskkill /F /IM ResearchDownload.exe',shell = True)
		else:
			for line in p.stdout:
				print(line.decode(encoding = 'utf-8', errors='ignore'))
				line = line.decode(encoding = 'utf-8', errors='replace' if (sys.version_info) < (3, 5) else 'backslashreplace').rstrip()
				if self.string in line:
					pub.sendMessage('updateProgress', arg1=line[line.find(self.string)+len(self.string):-1])
					timeMonitor = line[line.find(self.string)+len(self.string):-1]
					if '"progress" : 100,' in line: 
						p = subprocess.Popen(r'taskkill /F /IM adownload.exe',shell = True)
						statusBarStr = ""
						return

class EditFilePopup(wx.Menu):
	"""
	Custom Menu class for handling edit file from selected editor\n
	@Params: file_path - Full path to the file\n
	@Params: selected_app - Full path to the application of choice

	@Return: None
	"""
	def __init__(self, parent, selected_app, file_path):
		super(EditFilePopup, self).__init__()

		self.parent = parent
		self.file_path = file_path
		self.selected_app = selected_app
		
		emi = wx.MenuItem(self, wx.ID_ANY, 'Edit')
		self.Append(emi)
		self.Bind(wx.EVT_MENU, self.open_editor, emi)


	def open_editor(self, file_path):
		arg_list = [self.file_path, self.selected_app]
		subprocess.call(arg_list)


class CMDDialog(wx.Dialog):
	"""
	Custom Menu class for handling user addition of quickCMDs\n
	@Params: None\n

	@Return: None
	"""
	def __init__(self, parent):
		wx.Dialog.__init__(self, parent, title=_(u"配置工具箱命令"))

		self.panel = wx.Panel(self)
		self.main_sizer = wx.BoxSizer(wx.VERTICAL)

		# Panel sizer and widgets for text input
		self.panel_sizer = wx.BoxSizer(wx.VERTICAL)
		self.vbox1 = wx.BoxSizer(wx.VERTICAL)
		self.cmd_name = wx.StaticText(self.panel, wx.ID_ANY, _(u"名称:"))
		self.vbox1.Add(self.cmd_name, proportion=1, flag=wx.LEFT | wx.EXPAND)
		self.text_name = wx.TextCtrl(self.panel, wx.ID_ANY)
		self.text_name.SetMinSize((200, -1))
		self.vbox1.Add(self.text_name)
		
		self.vbox2 = wx.BoxSizer(wx.VERTICAL)
		self.cmd_content = wx.StaticText(self.panel,
										 wx.ID_ANY,
										 _(u"命令:")
		)
		self.vbox1.Add(self.cmd_content,
					   proportion=1,
					   flag=wx.LEFT | wx.EXPAND,
		)   
		self.text_content = wx.TextCtrl(self.panel, 
										wx.ID_ANY, 
										style=wx.TE_MULTILINE
		)
		self.text_content.SetMinSize((400, 200))
		self.vbox1.Add(self.text_content)

		# Button definitions and bindings
		self.button_add = wx.Button(self.panel, wx.ID_ANY, label=_(u'新增'))
		self.button_add.Bind(wx.EVT_BUTTON, self.add_btn_handler)
		self.button_close = wx.Button(self.panel, wx.ID_ANY, label=_(u'关闭'))
		self.button_close.Bind(wx.EVT_BUTTON, self.close_btn_handler)

		# Add widgets to the panel sizer component
		self.panel_sizer.Add(self.vbox1, flag=wx.TOP | wx.EXPAND, border=15)
		self.panel_sizer.Add(self.vbox2, flag=wx.TOP | wx.EXPAND, border=15)
		self.panel_sizer.Add(self.button_add, flag=wx.TOP, border=15)
		self.panel_sizer.Add(self.button_close, flag=wx.TOP, border=5)

		self.panel.SetSizer(self.panel_sizer)

		self.main_sizer.Add(self.panel,
							proportion=1,
							flag=wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND,
							border=15
		)
		
		# Apply sizer and display dialog panel
		self.SetSizerAndFit(self.main_sizer)
		self.Layout()
		self.Center()

	# Button bindings
	def close_btn_handler(self, event):
		self.Close()

	def add_btn_handler(self, event):
		config = configparser.ConfigParser(interpolation=None)
		cfg_path = PROJECT_ABSOLUTE_PATH + "\\config.ini"
		config.read(cfg_path,encoding='utf-8')

		q_cmd_name = self.text_name.GetValue()
		q_cmd = self.text_content.GetValue()

		curr_cmd_count = int(config.get('QuickCMD', 'cmdcnt'))

		if curr_cmd_count == 16:
			wx.MessageBox(_(u'内置命令的最大限制是16!'),
						  _(u'提示'),
						  wx.YES_DEFAULT | wx.ICON_WARNING
			)
			return

		if len(q_cmd_name) > 15:
			wx.MessageBox(_(u'命令长度不可超过15个字符！'),
						  _(u'提示'),
						  wx.YES_DEFAULT | wx.ICON_WARNING
			)
			return
		
		if q_cmd_name != '' and q_cmd != '':
			new_cmd_count = str(int(config.get('QuickCMD', 'cmdcnt')) + 1)
			config.set("QuickCMD", 'cmdcnt', new_cmd_count)
			
			new_cmd_name = 'cmd' + new_cmd_count
			modified_cmd = q_cmd.replace('\n', '\\r\\n')
			modified_cmd = modified_cmd + '\\r\\n'
			new_cmd = q_cmd_name + '|' + modified_cmd
			config.set("QuickCMD", new_cmd_name, new_cmd)
		
			with open(cfg_path, "w+", encoding='utf-8') as f:
				config.write(f)
		else:
			return


class FileDrop(wx.FileDropTarget):  #This is the file drop target
	def __init__(self, window):
		wx.FileDropTarget.__init__(self)  #File Drop targets are subsets of windows
		self.window = window

	def OnDropFiles(self, x, y, filenames):   #FileDropTarget now fills in the ListOfFiles
		pub.sendMessage("dragAndDrop", arg1=filenames)

		return True


class redirect_err:
	""""""
	#----------------------------------------------------------------------
	def __init__(self, obj):
		"""Constructor"""
		if ifExist(PROJECT_ABSOLUTE_PATH + "\\logs\\software\\err\\")==False:
			makeDir(PROJECT_ABSOLUTE_PATH + "\\logs\\software\\err\\")
			
		file_path = PROJECT_ABSOLUTE_PATH + "\\logs\\software\\err\\" + open_time + "_run_err.log"
		self.filename = open(file_path, "a",encoding = 'utf-8')
		
	#----------------------------------------------------------------------
	def write(self, text):
		""""""
		if self.filename.closed:
			pass
		else:
			curr_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
			self.filename.write('['+ str(curr_time) + '] ' + text)
			self.filename.flush()

class redirect_std:
	""""""
	#----------------------------------------------------------------------
	def __init__(self, obj):
		"""Constructor"""
		if ifExist(PROJECT_ABSOLUTE_PATH + "\\logs\\software\\std\\")==False:
			makeDir(PROJECT_ABSOLUTE_PATH + "\\logs\\software\\std\\")
		file_path = PROJECT_ABSOLUTE_PATH + "\\logs\\software\\std\\" + open_time + "_run_std.log"
		self.filename = open(file_path, "a",encoding = 'utf-8')
		
	#----------------------------------------------------------------------
	def write(self, text):
		""""""
		if self.filename.closed:
			pass
		else:
			curr_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
			self.filename.write('['+ str(curr_time) + '] ' + text)
			self.filename.flush()

'''
class StandardOutWrite:
	def write(self, x):
		old_std.write(x.replace("\n", " [[%s]]\n" % str(datetime.datetime.now())))
'''
class qpyTools(wx.Frame):
	fileExtIcon = {}
	logVar = ""
	#for path str
	localFilePathRoot = False	#Root for list drivers; "" for nothing

	def __init__(self, *args, **kwds):
		# begin wxGlade: qpyTools.__init__
		kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
		wx.Frame.__init__(self, *args, **kwds)
		w = wx.SystemSettings.GetMetric(wx.SYS_SCREEN_X)
		h = wx.SystemSettings.GetMetric(wx.SYS_SCREEN_Y)
		self.SetSize((int(0.6 * w), int(0.7 * h)))
		# check resolution before starting
		if (wx.GetDisplaySize()[0]*wx.GetDisplaySize()[1]) <= 1366*768:
			self.Maximize(True)
		self.Center()
		# Error timestamp addition
		sys.stderr = redirect_err(self)
		sys.stdout = redirect_std(self)

		# Menu Bar
		self.menuBar = wx.MenuBar()
		wxglade_tmp_menu = wx.Menu()
		wxglade_tmp_menu.Append(2001, _(u"保存"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2001)
		wxglade_tmp_menu.AppendSeparator()
		wxglade_tmp_menu.Append(2002, _(u"退出"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2002)
		self.menuBar.Append(wxglade_tmp_menu, _(u"文件 (&F)"))
		wxglade_tmp_menu = wx.Menu()
		wxglade_tmp_menu.Append(2011, _(u"交互命令行"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2011)
		wxglade_tmp_menu.Append(2012, _(u"文件浏览"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2012)
		wxglade_tmp_menu.Append(2013, _(u"下载固件/脚本"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2013)
		wxglade_tmp_menu.Append(2014, _(u"软件设置"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2014)
		wxglade_tmp_menu.AppendSeparator()
		wxglade_tmp_menu_sub = wx.Menu()
		wxglade_tmp_menu_sub.Append(2021, _(u"简体中文 (zh_CN)"), "", wx.ITEM_RADIO)
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2021)
		wxglade_tmp_menu_sub.Append(2022, "English (en)", "", wx.ITEM_RADIO)
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2022)
		if languageTab == 'en':
			wxglade_tmp_menu_sub.Check(2022,True)
		elif languageTab == 'zh_CN':
			wxglade_tmp_menu_sub.Check(2021,True)
		# Language
		# wxglade_tmp_menu.Append(wx.ID_ANY, _(u"语言"), wxglade_tmp_menu_sub, "")
		wxglade_tmp_menu.AppendSubMenu(wxglade_tmp_menu_sub, _(u"语言"))
		wxglade_tmp_menu.AppendSeparator()
		wxglade_tmp_menu_sub = wx.Menu()
		wxglade_tmp_menu_sub.Append(2031, _(u"切换到..."), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2031)
		wxglade_tmp_menu_sub.Append(2032, _(u"日志另存为"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2032)
		# Module Log
		# wxglade_tmp_menu.Append(wx.ID_ANY, _(u"模块日志"), wxglade_tmp_menu_sub, "")
		wxglade_tmp_menu.AppendSubMenu(wxglade_tmp_menu_sub, _(u"模块日志"))
		wxglade_tmp_menu_sub = wx.Menu()
		wxglade_tmp_menu_sub.Append(2041, _(u"查看"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2041)
		wxglade_tmp_menu_sub.Append(2042, _(u"日志另存为"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2042)
		# Download Log
		# wxglade_tmp_menu.Append(wx.ID_ANY, _(u"下载日志"), wxglade_tmp_menu_sub, "")
		wxglade_tmp_menu.AppendSubMenu(wxglade_tmp_menu_sub, _(u"下载日志"))
		self.menuBar.Append(wxglade_tmp_menu, _(u"查看 (&V)"))
		wxglade_tmp_menu = wx.Menu()
		wxglade_tmp_menu.Append(2051, _(u"官方网站"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2051)
		wxglade_tmp_menu.AppendSeparator()
		wxglade_tmp_menu.Append(2052, _(u"在线Wiki"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2052)
		wxglade_tmp_menu.Append(2053, _(u"在线教程"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2053)
		wxglade_tmp_menu.Append(2054, _(u"QQ开发交流群"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2054)
		wxglade_tmp_menu.AppendSeparator()
		wxglade_tmp_menu.Append(2055, _(u"资料下载"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2055)
		self.menuBar.Append(wxglade_tmp_menu, _(u"教程 (&E)"))
		wxglade_tmp_menu = wx.Menu()
		wxglade_tmp_menu.Append(2061, _(u"检查升级"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2061)
		wxglade_tmp_menu.AppendSeparator()
		wxglade_tmp_menu.Append(2065, _(u"版本信息"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2065)
		wxglade_tmp_menu.Append(2066, _(u"使用指导"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2066)
		wxglade_tmp_menu.AppendSeparator()
		wxglade_tmp_menu.Append(2062, _(u"关于 Quectel 移远"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2062)
		wxglade_tmp_menu.Append(2063, _(u"关于 QuecPython"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2063)
		wxglade_tmp_menu.Append(2064, _(u"版本"), "")
		self.Bind(wx.EVT_MENU, self.menuHandler, id=2064)
		self.menuBar.Append(wxglade_tmp_menu, _(u"帮助 (&H)"))
		self.SetMenuBar(self.menuBar)
		# Menu Bar end
		self.statusBar = self.CreateStatusBar(3)
		
		# Tool Bar
		self.toolBar = wx.ToolBar(self, -1)
		self.SetToolBar(self.toolBar)
		self.toolBar.AddSeparator()
		self.toolBar.AddTool(3011, _(u"开始"), wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\play-disable.ico", wx.BITMAP_TYPE_ICO), wx.NullBitmap, wx.ITEM_NORMAL, "", _(u"开启模块命令行交互"))
		self.toolBar.AddSeparator()
		self.toolBar.AddTool(3012, _(u"暂停"), wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\pause-disable.ico", wx.BITMAP_TYPE_ICO), wx.NullBitmap, wx.ITEM_NORMAL, "", _(u"暂停模块命令行交互"))
		self.toolBar.AddSeparator()
		self.toolBar.AddTool(3013, _(u"停止"), wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\stop.ico", wx.BITMAP_TYPE_ICO), wx.NullBitmap, wx.ITEM_NORMAL, "", _(u"停止模块命令行交互"))
		self.toolBar.AddSeparator()
		self.toolBar.AddTool(3014, _(u"清除"), wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\clean.ico", wx.BITMAP_TYPE_ICO), wx.NullBitmap, wx.ITEM_NORMAL, "", _(u"屏幕打印清除"))
		self.toolBar.AddSeparator()
		self.toolBar.AddSeparator()
		self.toolBar.AddSeparator()
		self.toolBar.AddTool(3001, _(u"时间戳"), wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\timerstamp.ico", wx.BITMAP_TYPE_ICO), wx.NullBitmap, wx.ITEM_CHECK, "", _(u"显示打印时间"))
		self.toolBar.AddSeparator()
		self.toolBar.AddTool(3002, _(u"显示行号"), wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\linenumber.ico", wx.BITMAP_TYPE_ICO), wx.NullBitmap, wx.ITEM_CHECK, "", _(u"行号显示"))
		self.toolBar.AddSeparator()
		self.toolBar.AddTool(3003, _(u"格式"), wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\format.ico", wx.BITMAP_TYPE_ICO), wx.NullBitmap, wx.ITEM_CHECK, "", _(u"交互页面主题切换"))
		self.toolBar.AddSeparator()
		self.toolBar.AddSeparator()
		self.toolBar.AddSeparator()
		self.toolBar.AddTool(3021, _(u"保存"), wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\save.ico", wx.BITMAP_TYPE_ICO), wx.NullBitmap, wx.ITEM_NORMAL, "", _(u"日志保存"))
		self.toolBar.AddSeparator()
		self.toolBar.AddTool(3022, _(u"搜索"), wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\search.ico", wx.BITMAP_TYPE_ICO), wx.NullBitmap, wx.ITEM_NORMAL, "", _(u"日志关键字搜索"))
		self.toolBar.AddSeparator()
		self.toolBar.AddSeparator()
		self.toolBar.AddSeparator()
		self.toolBar.AddTool(3031, _(u"设置"), wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\settings.ico", wx.BITMAP_TYPE_ICO), wx.NullBitmap, wx.ITEM_NORMAL, "", _(u"设置"))
		self.toolBar.AddSeparator()
		self.toolBar.AddTool(3032, _(u"工具箱"), wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\box.ico", wx.BITMAP_TYPE_ICO), wx.NullBitmap, wx.ITEM_NORMAL, "", _(u"工具箱"))
		self.toolBar.AddSeparator()
		self.toolBar.AddTool(3033, _(u"工具箱配置"), wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\add-box.ico", wx.BITMAP_TYPE_ICO), wx.NullBitmap, wx.ITEM_NORMAL, "", _(u"配置工具箱命令"))
		self.toolBar.AddSeparator()
		self.toolBar.AddTool(3034, _(u"置顶"), wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\ontop-disable.ico", wx.BITMAP_TYPE_ICO), wx.NullBitmap, wx.ITEM_NORMAL, "", _(u"窗口置顶"))
		
		# Tool Bar end
		self.label_4 = wx.StaticText(self, wx.ID_ANY, _(u"选择串口"))
		self.comSelector = wx.Choice(self, wx.ID_ANY, choices=[])
		self.label_3 = wx.StaticText(self, wx.ID_ANY, _(u"波特率"))
		self.comBaud = wx.ComboBox(self, wx.ID_ANY, choices=["1200", "2400", "4800", "9600", "14400", "19200", "38400", "57600", "115200", "230400", "256000", "460800", "921600"], style=wx.CB_DROPDOWN | wx.CB_READONLY)
		self.comOpen = wx.Button(self, 10006, _(u"打开串口"))
		self.comSettingMore = wx.Button(self, wx.ID_ANY, "...", style=wx.BU_BOTTOM)
		self.notebook_1 = wx.Notebook(self, wx.ID_ANY)
		self.notebook_1_pane_1 = wx.Panel(self.notebook_1, wx.ID_ANY)
		self.stc = wx.stc.StyledTextCtrl(self.notebook_1_pane_1, wx.ID_ANY)
		self.stc.SetLexer(stc.STC_LEX_PYTHON)
		self.stc.SetKeyWords(0, " ".join(keyword.kwlist))
		self.stc.Bind(wx.EVT_KEY_DOWN, self.DoKeyPress)
		self.stc.Bind(wx.EVT_KEY_UP, self.forbidChar) # [F9] Ignore Chinese letters
		# self.stc.Bind(wx.EVT_MOTION, self.forbidChar) # [F9] Ignore Chinese letters
		self.stc.Bind(wx.EVT_CONTEXT_MENU, self.OnSTCContextMenu)

		self.CONTENT = None # [F9] Ignore Chinese letters


		self.stc.SetTabWidth(4)
		self.stc.SetIndent(4)
		#self.stcColorized(True)
		self.stcLineNumberdisplayMode = 1
		self.stc.SetValue(">>> ")
		self.stc.SetWrapMode(1)
		self.notebook_1_pane_2 = wx.Panel(self.notebook_1, wx.ID_ANY)
		self.fileSplitter = wx.SplitterWindow(self.notebook_1_pane_2, wx.ID_ANY)
		self.fileSplitter.SetSashGravity(0.5)
		self.window_1_pane_1 = wx.Panel(self.fileSplitter, wx.ID_ANY)
		self.localFilePathGoUp = wx.BitmapButton(self.window_1_pane_1, wx.ID_ANY, wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\goesup.ico", wx.BITMAP_TYPE_ICO), style=wx.BU_BOTTOM)
		self.localFilePathReFresh = wx.BitmapButton(self.window_1_pane_1, wx.ID_ANY, wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\refresh.ico", wx.BITMAP_TYPE_ICO), style=wx.BU_BOTTOM)
		self.localFilePath = wx.TextCtrl(self.window_1_pane_1, wx.ID_ANY, "")
		self.localFilePathGo = wx.BitmapButton(self.window_1_pane_1, wx.ID_ANY, wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\enter.ico", wx.BITMAP_TYPE_ICO), style=wx.BU_BOTTOM)
		self.localFileList = wx.ListCtrl(self.window_1_pane_1, wx.ID_ANY, style=wx.LC_HRULES | wx.LC_REPORT | wx.LC_SINGLE_SEL | wx.LC_VRULES)
		self.window_1_pane_2 = wx.Panel(self.fileSplitter, wx.ID_ANY)
		self.modFileRefresh = wx.BitmapButton(self.window_1_pane_2, wx.ID_ANY, wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\refresh.ico", wx.BITMAP_TYPE_ICO), style=wx.BU_BOTTOM)
		self.modFileRefresh.SetToolTip("Refresh")
		self.modFileExec = wx.BitmapButton(self.window_1_pane_2, wx.ID_ANY, wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\exec.ico", wx.BITMAP_TYPE_ICO), style=wx.BU_BOTTOM)
		self.modFileExec.SetToolTip("Run")
		self.modFileAdd = wx.BitmapButton(self.window_1_pane_2, wx.ID_ANY, wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\add.ico", wx.BITMAP_TYPE_ICO), style=wx.BU_BOTTOM)
		self.modFileAdd.SetToolTip("Add")
		self.modFileRm = wx.BitmapButton(self.window_1_pane_2, wx.ID_ANY, wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\delete.ico", wx.BITMAP_TYPE_ICO), style=wx.BU_BOTTOM)
		self.modFileRm.SetToolTip("Remove")
		self.modFileClean = wx.BitmapButton(self.window_1_pane_2, wx.ID_ANY, wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\deleteall.ico", wx.BITMAP_TYPE_ICO), style=wx.BU_BOTTOM)
		self.modFileClean.SetToolTip("Clear")
		self.modFileTree = wx.TreeCtrl(self.window_1_pane_2, wx.ID_ANY)
		TreeDropVar = treeDrop(self.modFileTree)
		self.modFileTree.SetDropTarget(TreeDropVar)
		self.notebook_1_pane_3 = wx.Panel(self.notebook_1, wx.ID_ANY)
		self.projectList = wx.ListBox(self.notebook_1_pane_3, wx.ID_ANY, choices=[])
		self.projectCreat = wx.Button(self.notebook_1_pane_3, wx.ID_ANY, _(u"创建"))
		self.projectDelete = wx.Button(self.notebook_1_pane_3, wx.ID_ANY, _(u"删除"))
		self.firmwarePath = wx.TextCtrl(self.notebook_1_pane_3, wx.ID_ANY, "")
		self.firmwareBrowser = wx.Button(self.notebook_1_pane_3, wx.ID_ANY, _(u"选择固件"))		
		self.howGetFirmware = wx.BitmapButton(self.notebook_1_pane_3, wx.ID_ANY, wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\how.ico", wx.BITMAP_TYPE_ICO), style=wx.BU_BOTTOM)
		self.howGetFirmware.SetToolTip("how to get firmware")
		self.downloadFileList = wx.ListCtrl(self.notebook_1_pane_3, wx.ID_ANY, style=wx.LC_HRULES | wx.LC_REPORT | wx.LC_VRULES)
		self.downloadFileAdd = wx.BitmapButton(self.notebook_1_pane_3, wx.ID_ANY, wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\add.ico", wx.BITMAP_TYPE_ICO), style=wx.BU_BOTTOM)
		self.downloadFileAdd.SetToolTip("Add")
		self.downloadFileRm = wx.BitmapButton(self.notebook_1_pane_3, wx.ID_ANY, wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\delete.ico", wx.BITMAP_TYPE_ICO), style=wx.BU_BOTTOM)
		self.downloadFileRm.SetToolTip("Delete")
		self.downloadFileClean = wx.BitmapButton(self.notebook_1_pane_3, wx.ID_ANY, wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\deleteall.ico", wx.BITMAP_TYPE_ICO), style=wx.BU_BOTTOM)
		self.downloadFileClean.SetToolTip("Clear")
		self.downloadFileEncrypt = wx.CheckBox(self.notebook_1_pane_3, wx.ID_ANY, _(u"加密"))
		# self.downloadFileCompress = wx.CheckBox(self.notebook_1_pane_3, wx.ID_ANY, _(u"压缩"))
		self.downloadFileBackup = wx.CheckBox(self.notebook_1_pane_3, wx.ID_ANY, _(u"备份"))
		self.downloadProgress = wx.Gauge(self.notebook_1_pane_3, wx.ID_ANY, 100)
		self.downloadFileStart = wx.Button(self.notebook_1_pane_3, wx.ID_ANY, _(u"下载脚本"))
		self.downloadFileStart.SetLabel(_(u"下载脚本"))
		self.downloadFileMore = wx.Button(self.notebook_1_pane_3, 5001, u"▼")
		self.downloadFileCombine = wx.Button(self.notebook_1_pane_3, wx.ID_ANY, _(u"合并"))
		self.notebook_1_pane_4 = wx.Panel(self.notebook_1, wx.ID_ANY)
		self.autoSaveLogChk = wx.CheckBox(self.notebook_1_pane_4, wx.ID_ANY, _(u"自动保存模块日志"))
		self.label_7 = wx.StaticText(self.notebook_1_pane_4, wx.ID_ANY, _(u"最大保存数目"))
		self.autoSaveLogMaxItem = wx.TextCtrl(self.notebook_1_pane_4, wx.ID_ANY, "10")
		self.label_8 = wx.StaticText(self.notebook_1_pane_4, wx.ID_ANY, _(u"最大占用上限(MB)"))
		self.autoSaveLogMaxSize = wx.TextCtrl(self.notebook_1_pane_4, wx.ID_ANY, "100")
		self.openAutoSaveLogDir = wx.Button(self.notebook_1_pane_4, wx.ID_ANY, _(u"打开日志文件夹"))
		self.codeEditorChk = wx.CheckBox(self.notebook_1_pane_4, wx.ID_ANY, _(u"源码编辑器"))
		self.codeEditorPathText = wx.TextCtrl(self.notebook_1_pane_4, wx.ID_ANY, "", style=wx.TE_READONLY)
		self.srcEditorBrowseBtn = wx.Button(self.notebook_1_pane_4, wx.ID_ANY, "...", style=wx.BU_BOTTOM)
		self.label_13 = wx.StaticText(self.notebook_1_pane_4, wx.ID_ANY, _(u"启动参数"))
		self.codeEditorParam = wx.TextCtrl(self.notebook_1_pane_4, wx.ID_ANY, "%f")
		self.comSettingChk = wx.CheckBox(self.notebook_1_pane_4, wx.ID_ANY, _(u"串口参数配置"))
		self.label_14 = wx.StaticText(self.notebook_1_pane_4, wx.ID_ANY, _(u"校验位"))
		self.comParity = wx.ComboBox(self.notebook_1_pane_4, wx.ID_ANY, choices=["NONE", "ODD", "EVEN", "MARK", "SPACE"], style=wx.CB_DROPDOWN | wx.CB_READONLY)
		self.label_15 = wx.StaticText(self.notebook_1_pane_4, wx.ID_ANY, _(u"数据位"))
		self.comDatabit = wx.ComboBox(self.notebook_1_pane_4, wx.ID_ANY, choices=["5", "6", "7", "8"], style=wx.CB_DROPDOWN | wx.CB_READONLY)
		self.label_16 = wx.StaticText(self.notebook_1_pane_4, wx.ID_ANY, _(u"停止位"))
		self.comStopbits = wx.ComboBox(self.notebook_1_pane_4, wx.ID_ANY, choices=["1", "1.5", "2"], style=wx.CB_DROPDOWN | wx.CB_READONLY)
		self.label_17 = wx.StaticText(self.notebook_1_pane_4, wx.ID_ANY, _(u"流控制"))
		self.comFlowControl = wx.ComboBox(self.notebook_1_pane_4, wx.ID_ANY, choices=["NONE", "XON/XOFF", "RTS/CTS", "DTR/DSR", "RTS/CTS/XON/XOFF", "DTR/DSR/XON/XOFF"], style=wx.CB_DROPDOWN | wx.CB_READONLY)
		self.mpycChk = wx.CheckBox(self.notebook_1_pane_4, wx.ID_ANY, _(u"mpy-cross 路径"))
		self.mpycPathText = wx.TextCtrl(self.notebook_1_pane_4, wx.ID_ANY, "", style=wx.TE_READONLY)
		self.mpycBrowser = wx.Button(self.notebook_1_pane_4, wx.ID_ANY, "...", style=wx.BU_BOTTOM)
		self.manualSettingChk = wx.CheckBox(self.notebook_1_pane_4, wx.ID_ANY, _(u"手动修改配置文件"))
		self.openConfigFile = wx.Button(self.notebook_1_pane_4, wx.ID_ANY, _(u"关闭工具并打开配置文件"))
		self.fontCheck = wx.CheckBox(self.notebook_1_pane_4, wx.ID_ANY, _(u"字体设置"))
		self.fontButton = wx.Button(self.notebook_1_pane_4, wx.ID_ANY, _(u"交互页面字体设置"))
		
		self.configConfirm = wx.Button(self.notebook_1_pane_4, wx.ID_ANY, _(u"确定"))
		self.configConfirm.SetToolTip("确定-保存修改并生效")
		self.configReset = wx.Button(self.notebook_1_pane_4, wx.ID_ANY, _(u"重置"))
		self.configReset.SetToolTip("重置-恢复默认选项")
		self.configCancel = wx.Button(self.notebook_1_pane_4, wx.ID_ANY, _(u"取消"))
		self.configCancel.SetToolTip("取消-放弃本次修改")

		self.__set_properties()
		self.__do_layout()
		

		self.Bind(wx.EVT_TOOL, self.toolBarHandler, id=3011)
		self.Bind(wx.EVT_TOOL, self.toolBarHandler, id=3012)
		self.Bind(wx.EVT_TOOL, self.toolBarHandler, id=3013)
		self.Bind(wx.EVT_TOOL, self.toolBarHandler, id=3014)
		self.Bind(wx.EVT_TOOL, self.toolBarHandler, id=3001)
		self.Bind(wx.EVT_TOOL, self.toolBarHandler, id=3002)
		self.Bind(wx.EVT_TOOL, self.toolBarHandler, id=3003)
		self.Bind(wx.EVT_TOOL, self.toolBarHandler, id=3021)
		self.Bind(wx.EVT_TOOL, self.toolBarHandler, id=3022)
		self.Bind(wx.EVT_TOOL, self.toolBarHandler, id=3031)
		self.Bind(wx.EVT_TOOL, self.toolBarHandler, id=3033)
		self.Bind(wx.EVT_TOOL, self.toolBarHandler, id=3034)
		self.Bind(wx.EVT_TOOL, self.CMDHandler, id=3032)
		self.Bind(wx.EVT_CHOICE, self.comSelectorChange, self.comSelector)
		self.Bind(wx.EVT_BUTTON, self.comOpenBtn, self.comOpen)
		self.Bind(wx.EVT_BUTTON, self.comSettingBtn, self.comSettingMore)
		self.Bind(wx.EVT_BUTTON, self.fileExploreGoUpHandler, self.localFilePathGoUp)
		self.Bind(wx.EVT_BUTTON, self.fileExploreReFreshHandler, self.localFilePathReFresh)
		self.Bind(wx.EVT_BUTTON, self.fileExploreGoHandler, self.localFilePathGo)
		self.Bind(wx.EVT_LIST_BEGIN_DRAG, self.fileListDragInit, self.localFileList)
		self.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.openEditor, self.localFileList)
		self.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.localFileListDoubleClickHandler, self.localFileList)
		#self.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.openEditorFromDownload, self.downloadFileList)
		self.Bind(wx.EVT_BUTTON, self.modFileRefreshFunc, self.modFileRefresh)
		self.Bind(wx.EVT_BUTTON, self.modFileRunFunc, self.modFileExec)
		self.Bind(wx.EVT_BUTTON, self.modFileAddFunc, self.modFileAdd)
		self.Bind(wx.EVT_BUTTON, self.modFileRmFunc, self.modFileRm)
		self.Bind(wx.EVT_BUTTON, self.modFileCleanFunc, self.modFileClean)
		self.Bind(wx.EVT_TREE_ITEM_EXPANDED, self.modFileTreeExpand, self.modFileTree)
		self.Bind(wx.EVT_CHECKBOX, self.autoSaveLogChkToggle, self.autoSaveLogChk)
		self.Bind(wx.EVT_BUTTON, self.openLogDir, self.openAutoSaveLogDir)
		self.Bind(wx.EVT_CHECKBOX, self.codeEditorToggle, self.codeEditorChk)
		self.Bind(wx.EVT_BUTTON, self.srcEditorBrowse, self.srcEditorBrowseBtn)
		self.Bind(wx.EVT_CHECKBOX, self.changeSerialSettingChk, self.comSettingChk)
		self.Bind(wx.EVT_CHECKBOX, self.mpycPathChk, self.mpycChk)
		self.Bind(wx.EVT_BUTTON, self.mpycPathBrowse, self.mpycBrowser)
		self.Bind(wx.EVT_CHECKBOX, self.manualEditConfigure, self.manualSettingChk)
		self.Bind(wx.EVT_BUTTON, self.openConfigureFile, self.openConfigFile)
		self.Bind(wx.EVT_CHECKBOX, self.fontCheckConfigure, self.fontCheck)
		self.Bind(wx.EVT_BUTTON, self.onFontConfigure, self.fontButton)
		self.Bind(wx.EVT_BUTTON, self.saveSettings, self.configConfirm)
		self.Bind(wx.EVT_BUTTON, self.resetSettigns, self.configReset)
		self.Bind(wx.EVT_BUTTON, self.restoreSettings, self.configCancel)
		self.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED, self.winTabChanged, self.notebook_1)
		self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)
		self.Bind(wx.EVT_BUTTON, self.howGetFirmwareFunc, self.howGetFirmware)
		# end wxGlade
		#user code
		self.mpycPathText.Bind(wx.EVT_SET_FOCUS, self.mpycPathBrowse)
		self.codeEditorPathText.Bind(wx.EVT_SET_FOCUS, self.srcEditorBrowse)
		#self.codeEditorParam.Bind(wx.EVT_TEXT, self.srcEditorParamSave)
		self.autoSaveLogMaxItem.Bind(wx.EVT_CHAR_HOOK, self.txtFilterNum)
		self.autoSaveLogMaxSize.Bind(wx.EVT_CHAR_HOOK, self.txtFilterNum)
		self.localFilePath.Bind(wx.EVT_CHAR_HOOK, self.filePathHandler)
		self.projectList.Bind(wx.EVT_KEY_UP, self.delete)
		#self.Bind(wx.EVT_SIZE, self.OnReSize, self)
		
		#statusBar data timer
		self.statusBarTimer = wx.Timer(self)
		self.Bind(wx.EVT_TIMER, self.statusBarTimerFresh, self.statusBarTimer)
		self.statusBarTimer.Start(100)

		#lineWidthTimerFix data timer
		self.lineWidthTimer = wx.Timer(self)
		self.Bind(wx.EVT_TIMER, self.lineWidthTimerFix, self.lineWidthTimer)
		self.lineWidthTimer.Start(100)
		
		#serial rcv data timer
		self.serRcvTimer = wx.Timer(self)
		self.Bind(wx.EVT_TIMER, self.serRcvHandler, self.serRcvTimer)
		
		#auto save log timer
		self.autoSaveLogTimer = wx.Timer(self)
		self.Bind(wx.EVT_TIMER, self.autoSaveLogHandler, self.autoSaveLogTimer)
		self.autoSaveLogTimer.Start(5000)
		
		#msg for update ui form
		pub.subscribe(self.updateDisplay, "uiUpdate")
		pub.subscribe(self.statusBarMessages, "statusBarUpdate")

		#toolbar toggle 
		self.toolBar.ToggleTool(3001, False)	#timestamp
		self.toolBar.ToggleTool(3002, True)	#line number
		self.toolBar.ToggleTool(3003, True)	#format render
		
		#for serial
		self.serSendList = ['\r\n']
		
		#for log pause boolean
		self.logPrtPause = False
		self.logPrtPauseCache = True
		self.logCache = []

		# For solving flickering frame issues
		self.notebook_1_pane_4.SetDoubleBuffered(True)
		
		#for listview icon
		self.FileIconList = wx.ImageList(24,24)
		self.localFileList.SetImageList(self.FileIconList, wx.IMAGE_LIST_SMALL)
		#self.treeIconList = wx.ImageList(16,16)
		self.treeIconList = wx.ImageList(24,24)
		self.modFileTree.AssignImageList(self.treeIconList)
		self.fldridx = self.treeIconList.Add(wx.ArtProvider.GetBitmap(wx.ART_FOLDER, wx.ART_OTHER, (24,24)))
		self.fldropenidx = self.treeIconList.Add(wx.ArtProvider.GetBitmap(wx.ART_FOLDER, wx.ART_OTHER, (24,24)))
		self.fileidx = self.treeIconList.Add(wx.ArtProvider.GetBitmap(wx.ART_NORMAL_FILE, wx.ART_OTHER, (24,24)))
		self.filepy = self.treeIconList.Add(wx.Icon(PROJECT_ABSOLUTE_PATH + "\\images\\pyfile.ico", wx.BITMAP_TYPE_ICO))
		
		#for file tree, add root item
		self.addTree(self.modFileTree, "", "", True, True)
		#for treectrl tooltip
		self.modFileTree.Bind(wx.EVT_MOTION, self.modFileTreeMouseMotion)
		# for RIGHT_CLICK event modFileTree
		self.modFileTree.Bind(wx.EVT_TREE_ITEM_RIGHT_CLICK, self.modFileTreeRightClick)
		# self.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.modFileTreeRightClick, self.modFileTree)
		#for ser log
		self.serProCache = ""

		#for init config file
		self.conf = configparser.ConfigParser(interpolation=None)
		if not ifExist(PROJECT_ABSOLUTE_PATH+"\\config.ini"):
			self.initConfigFile(True)
		self.conf.read(PROJECT_ABSOLUTE_PATH+"\\config.ini", encoding='utf-8')
		self.getConfigValue()
		self.stc_colour = tuple()
		colour = self.conf.get('font', 'colour')
		self.stc_colour = tuple(int(s) for s in colour[1:-1].split(','))

		self.stcColorized(True, 
						  self.conf.getboolean('font', 'default'),
						  self.stc_colour
		)
		
		# self.stc_colour = tuple()
		# # init stc font
		# if self.conf.getboolean('font', 'default'):
		#	 self.font = wx.Font(12,
		#						 wx.MODERN,
		#						 wx.NORMAL,
		#						 wx.NORMAL,
		#						 False,
		#						 'Lucida Sans Typewriter'
		#				 )
		# else:
		#	 curr_data = {
		#		 'pointSize': self.conf.getint('font', 'pointSize'),
		#		 'family': self.conf.getint('font', 'family'),
		#		 'style': self.conf.getint('font', 'style'),
		#		 'weight': self.conf.getint('font', 'weight'),
		#		 'underline': self.conf.getboolean('font', 'underline'),
		#		 'face': self.conf.get('font', 'face'),
		#		 'encoding': self.conf.getint('font', 'encoding')
		#	 }

		#	 self.font = wx.Font(curr_data['pointSize'],
		#						 wx.FontFamily(curr_data['family']),
		#						 wx.FontStyle(curr_data['style']),
		#						 wx.FontWeight(curr_data['weight']),
		#						 curr_data['underline'],
		#						 curr_data['face'],
		#						 wx.FontEncoding(curr_data['encoding'])
		#				 )

		#	 colour = self.conf.get('font', 'colour')
		#	 self.stc_colour = tuple(int(s) for s in colour[1:-1].split(','))

		# for i in range(12):
		#	 self.stc.StyleSetFont(i, self.font)
		#	 if len(self.stc_colour) != 0:
		#		 self.stc.StyleSetForeground(i,  self.stc_colour)

		# statusBarStr queue
		#self.qus = statusQueue()
		

## SLOBODAN ##

		self.Bind(wx.EVT_BUTTON, self.projectCreatFunc, self.projectCreat)
		self.Bind(wx.EVT_BUTTON, self.projectDeleteFunc, self.projectDelete)
		self.Bind(wx.EVT_LISTBOX, self.OnSelection, self.projectList)
		self.Bind(wx.EVT_BUTTON, self.firmwareBrowserFunc, self.firmwareBrowser)
		self.Bind(wx.EVT_BUTTON, self.downloadFileAddFunc, self.downloadFileAdd)
		self.Bind(wx.EVT_BUTTON, self.downloadFileRmFunc, self.downloadFileRm)
		self.Bind(wx.EVT_BUTTON, self.downloadFileCleanFunc, self.downloadFileClean)
		self.Bind(wx.EVT_BUTTON, self.downloadFileStartFunc, self.downloadFileStart)
		self.Bind(wx.EVT_BUTTON, self.downloadFileCombineStart, self.downloadFileCombine)
		
		self.index = 0
		self.pCfg = self.readJSON(PROJECT_ABSOLUTE_PATH + '\\' + 'fw_config.json')
		self.mount = PROJECT_ABSOLUTE_PATH + '\\' + self.pCfg["firmware"]["pack_dir"]
		self.mpy = PROJECT_ABSOLUTE_PATH + '\\' + self.pCfg["firmware"]["mpy_dir"]
		self.backup = PROJECT_ABSOLUTE_PATH + '\\' + self.pCfg["firmware"]["backup_dir"]
		self.project = PROJECT_ABSOLUTE_PATH + '\\' + "project"
		self.fw_images = PROJECT_ABSOLUTE_PATH + '\\' + "fw\\images"
		self.config = {'firmware_name': [], 'path_name': []}
		
		# downloading fw_script
		self.downloadFileMore.Bind(wx.EVT_LEFT_DOWN, self.OnDownloadContextMenu, self.downloadFileMore)
		#self.Bind(wx.EVT_CONTEXT_MENU, self.OnDownloadContextMenu, self.downloadFileMore)

		# Persistance of project List
		self.config_ls = getFileList(self.project)
		self.full_path_ls = [self.project + '\\' + f for f in self.config_ls]
		self.full_path_ls.sort(key=os.path.getctime)
		self.full_path_ls = [os.path.basename(f_path) for f_path in self.full_path_ls]
		if self.full_path_ls:
			self.project_ls = [fileNameSplit(cfg_ls)[0] for cfg_ls in self.full_path_ls]
			[self.projectList.Append(prj_ls) for prj_ls in self.project_ls]
		## Implement persistance with order that was before closing and also perserve selected project (the second thing is not neccessary)
		
		
		# get info after init
		get_info_func = getUsageInfo({"trigger": 0,"project_count": self.projectList.GetCount(),"QPYcom_version": versionGlobal})

		# drag and drop - set ListCtrl as DropTarget and establish source
		self.DropTarget = FileDrop(self) # [F3] Drag and Drop to the Download ListCtrl
		self.downloadFileList.SetDropTarget(self.DropTarget) # [F3] Drag and Drop to the Download ListCtrl

		# subscribe function to topic for drag and drop
		pub.subscribe(self.dragAndDrop, "dragAndDrop")
		
	# font Configure
	def onFontConfigure(self,event):
		dialog = wx.FontDialog(None, wx.FontData())
		if dialog.ShowModal() == wx.ID_OK:
			data = dialog.GetFontData()
			Font = data.GetChosenFont()
			colour = data.GetColour()

			self.conf.set('font', 'default', 'False')
			self.conf.set('font', 'fontFace', str(Font.FaceName))
			self.conf.set('font', 
						  'bold', 
						  'True' if Font.Weight >= 700 else 'False'
			)
			self.conf.set('font', 
						  'italic', 
						  'True' if Font.Style == wx.ITALIC else 'False'
			)
			self.conf.set('font', 'underline', str(Font.GetUnderlined()))
			self.conf.set('font', 'encoding', str(Font.Encoding))
			self.conf.set('font', 'colour', str(colour))

			cfg_path = PROJECT_ABSOLUTE_PATH + "\\config.ini"
			with open(cfg_path,"w+", encoding='utf-8') as f:
				self.conf.write(f)

			self.stc_colour = colour
			self.stcColorized(self.toolBar.GetToolState(3003), False, colour)
	# delete project on delete key in project list
	def delete(self, event):
		keycode = event.GetKeyCode()
		if keycode == wx.WXK_DELETE:
			self.projectDeleteFunc(event)
			

	# exit app
	def OnCloseWindow(self,event):
		'''
		file_path_err = PROJECT_ABSOLUTE_PATH + "\\logs\\software\\run_err.log"
		file_path_std = PROJECT_ABSOLUTE_PATH + "\\logs\\software\\run_std.log"
		try:
			for logfile in [file_path_err, file_path_std]:
				temp_data = []
				new_data = []

				with open(logfile, 'r',encoding = 'utf-8') as f:
					temp_data = f.readlines()

				for line in temp_data:
					timestamp = line[0:22]
					line = line.replace(timestamp, "")
					new_data.append(timestamp + ' ' + line)
				
				with open(logfile, 'w',encoding = 'utf-8') as f:
					temp_data = f.writelines(new_data)
		except:
			print('保存日志文件失败')
		finally:
		'''
		get_info_func = getUsageInfo({"trigger": 2,"project_count": self.projectList.GetCount(),"QPYcom_version": versionGlobal})
		time.sleep(0.2)
		self.Destroy()
		wx.GetApp().ExitMainLoop()
		wx.Exit()
		process_name = "taskkill /F /IM " + file_name 
		p = subprocess.Popen(process_name, shell = True)
	
	# The function which find correct serial port
	def comPortNumber(self, vid_pid, port=""):
		print(vid_pid.values())
		for p in list(serPort.comports()):
			for i in vid_pid.values():
				if port == "":
					if i in p.hwid:
						return p.device
				else:
					if i and port in p.hwid:
						return p.device
					
	
	# The function which waits until a port appears
	def waitToPort(self, vid_pid, port=""):
		# delay = 60*0.5	  ### for 30 seconds
		# end_time = time.time() + delay
		# while self.comPortNumber(vid_pid, port) == None:
			# time.sleep(0.5)
			# if time.time() > end_time:
				# break
		for i in range(60):	
			time.sleep(0.5)
			if self.comPortNumber(vid_pid, port) != None:
				break


	
	def readJSON(self, jsonName):
		with codecs.open(jsonName, 'r', 'utf-8') as f:
			data = json.load(f)
		return data

	def writeJSON(self, data, jsonName):
		with codecs.open(jsonName, 'w', 'utf-8') as f:
			json.dump(data, f, ensure_ascii = False, indent=2)
			
	def atGetVersion(self):
		#cmd = 'AT+CGMP'
		cmd = 'AT+GMR'
		atPort = self.comPortNumber(self.pCfg["firmware"]["vid_pid_work"], 
									self.pCfg["firmware"]["Quectel_USB_AT_Port"])
		# atPort = self.atPortNumber()						
		if atPort is None:
			return None
		try:
			s = QuecPort(atPort)
			s.OpenConn()
			s.SendCmd(cmd)
		
			version_data = s.RecvCmd().decode("utf-8", errors="ignore")
			#print(s.RecvCmd().decode("utf-8", errors="ignore"))
			s.CloseConn()
			return version_data[9:19]
		except Exception as e:
			# wx.MessageBox(_(u'打开AT串口失败'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			return
		
	### PETAR
	def atGetPythonVersion(self):
		try:
			cmd = 'AT+GMR'
			atPort = self.comPortNumber(self.pCfg["firmware"]["vid_pid_work"], 
										self.pCfg["firmware"]["Quectel_USB_AT_Port"])												
			i = 1
			python_ver_flag = 0	
			while i < 2:
				s = QuecPort(atPort)
				s.OpenConn()
				s.SendCmd(cmd)	
				version_data = s.RecvCmd().decode("utf-8", errors="ignore")+s.RecvCmd().decode("utf-8", errors="ignore")
				# print(version_data)
				s.CloseConn()
				if "_PY" in version_data:
					python_ver_flag = 1
				i+=1
			return python_ver_flag
		except Exception as e:
			pass

	def getSimStatus(self):
		cmd = "import sim\r\nsim.getStatus()\r\nend=1\r\n"		
		try:
			SerialPort = self.comPortNumber(self.pCfg["firmware"]["vid_pid_work"], 
										self.pCfg["firmware"]["USB_Serial_Device"])	
			s = QuecPort(SerialPort)
			s.OpenConn()
			s.SendCmd(cmd)
			simStatus = s.RecvCmdUntil().decode("utf-8", errors="ignore")
			s.CloseConn()
			if simStatus[33] == "0":
				statusBarMsg = self.pCfg["sim_status"]["Remove"]
			elif simStatus[33] == "1":
				statusBarMsg = self.pCfg["sim_status"]["Ready"]
			else:
				statusBarMsg = self.pCfg["sim_status"]["Locked"]
			return statusBarMsg
		except Exception as e:
			print(e)

	def getDataCallInfo(self):
		cmd = "import dataCall\r\ndataCall.getInfo(1,0)\r\nend=1\r\n"
		try:
			SerialPort = self.comPortNumber(self.pCfg["firmware"]["vid_pid_work"], 
										self.pCfg["firmware"]["USB_Serial_Device"])			
			s = QuecPort(SerialPort)
			s.OpenConn()
			s.SendCmd(cmd)			 
			dataCallInfo = s.RecvCmdUntil().decode("utf-8", errors="ignore")
			s.CloseConn()
			if "[0" in dataCallInfo[50:60]:
				statusBarMsg = self.pCfg["dailing_status"]["Not_Connected"]
			elif "[1" in dataCallInfo[50:60]:
				statusBarMsg = self.pCfg["dailing_status"]["Connected"]
			else:
				statusBarMsg = self.pCfg["dailing_status"]["Error"]
			return statusBarMsg
		except Exception as e:
			pass

	def getNetState(self):
		cmd = "import net\r\nnet.getState()\r\nend=1\r\n"
		try:
			SerialPort = self.comPortNumber(self.pCfg["firmware"]["vid_pid_work"], 
										self.pCfg["firmware"]["USB_Serial_Device"])			
			s = QuecPort(SerialPort)
			s.OpenConn()
			s.SendCmd(cmd)		
			netState = s.RecvCmdUntil().decode("utf-8", errors="ignore")
			s.CloseConn()
			if "[0" in netState[40:80] or "[2" in netState[40:80]:
				statusBarMsg = self.pCfg["net_status"]["Not_Registered"]
			elif "[1" in netState[40:80]:
				statusBarMsg = self.pCfg["net_status"]["Registered"]
			elif "[3" in netState[40:80]:
				statusBarMsg = self.pCfg["net_status"]["Registered_Denied"]				
			elif "[4" in netState[40:80]:
				statusBarMsg = self.pCfg["net_status"]["Unknown"]
			elif "[5" in netState[40:80] or "[6" in netState[40:80] or "[7" in netState[40:80] \
				or "[8" in netState[40:80] or "[9" in netState[40:80] or "[10" in netState[40:80] \
				or "[11" in netState[40:80]:
				statusBarMsg = self.pCfg["net_status"]["Registration_Limited"]
			else:
				statusBarMsg = self.pCfg["net_status"]["Error"]
			return statusBarMsg
		except Exception as e:
			pass			
###
			
			
	def comPortReturn(self):
		#quectelPortStr = ['Quectel USB AT Port', 'Quectel Download Port']
		cmd = 'at+qdownload=1'
		if self.fw_fileName[-3:].lower()=="pac":
			atPort = self.comPortNumber(self.pCfg["firmware"]["vid_pid_work"], 
									self.pCfg["firmware"]["Quectel_USB_DIAG_Port"])
		else:
			
			atPort = self.comPortNumber(self.pCfg["firmware"]["vid_pid_work"], 
									self.pCfg["firmware"]["Quectel_USB_AT_Port"])									
		# print(atPort)
		if atPort == None:
			pass
		else:
			try:
				s = QuecPort(atPort)
				s.OpenConn()
				s.SendCmd(cmd)
				s.CloseConn()
				self.waitToPort(self.pCfg["firmware"]["vid_pid_dwload"])
			except Exception as e:
				self.notebook_1.Enable()
				self.comOpen.Enable()
				wx.MessageBox(_(u'打开AT串口失败'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				return
		T = threading.Thread(target=self.downloadTimeMonitor,args=())
		T.start()
		return self.comPortNumber(self.pCfg["firmware"]["vid_pid_dwload"])

	def mklfs(self,fileList):
		global combineFilePath, fifferenceFilePath, statusBarStr
		if self.fw_fileName[-3:].lower()=="pac":
			backupfile_size = self.pCfg["firmware"]["cnlb_filesystem_backup_size"]
			file_size = self.pCfg["firmware"]["cnlb_filesystem_size"]
		elif "cnlb" in self.fw_fileName.lower():
			backupfile_size = self.pCfg["firmware"]["cnlb_filesystem_backup_size"]
			file_size = self.pCfg["firmware"]["cnlb_filesystem_size"]
		else:
			# cnaa和大小和cnla一致
			backupfile_size = self.pCfg["firmware"]["filesystem_backup_size"]
			file_size = self.pCfg["firmware"]["filesystem_size"]
		if self.downloadFileEncrypt.GetValue():
			EncryptionFlag = self.pCfg["firmware"]["mpy_dir"]
		else:
			EncryptionFlag = self.pCfg["firmware"]["pack_dir"]
			cmd0 = ["exes\\aboot\\mklfs.exe", '-c', 
				PROJECT_ABSOLUTE_PATH + "\\" + self.pCfg["firmware"]["backup_dir"], '-b',
				self.pCfg["firmware"]["block_size"], '-r',
				self.pCfg["firmware"]["read_size"], '-p',
				self.pCfg["firmware"]["progress_size"], '-s',
				backupfile_size, '-i',
				PROJECT_ABSOLUTE_PATH + "\\fw\\images\\customer_backup_fs.bin"]
			print(cmd0)
			print('------------------mklfs creating and replacing customer_backup_fs.bin: ------------------')
			p0 = runSubprocess(cmd0)
			p = p0.runner()
			time.sleep(0.2)
			if p.poll() != 0:
				for i in range(10):
					print(p.poll())
					if p.poll() == None:
						time.sleep(0.5)
					elif p.poll() == 0:
						break
					else:
						wx.MessageBox(_(u'合并处理失败'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
						statusBarStr = ""
						return
			
			#print(p.poll())
				
		cmd1 = ["exes\\aboot\\mklfs.exe", '-c',
				PROJECT_ABSOLUTE_PATH + "\\" + EncryptionFlag, '-b',
				self.pCfg["firmware"]["block_size"], '-r',
				self.pCfg["firmware"]["read_size"], '-p',
				self.pCfg["firmware"]["progress_size"], '-s',
				file_size, '-i',
				PROJECT_ABSOLUTE_PATH + "\\fw\\images\\customer_fs.bin"]
		print(cmd1)		
		print('------------------mklfs creating and replacing customer_fs.bin: ------------------')
		p1 = runSubprocess(cmd1)
		p = p1.runner()
		time.sleep(0.2)
		if p.poll() != 0:
			for i in range(10):
				if p.poll() == None:
					time.sleep(1)
				elif p.poll() == 0:
					break
				else:
					wx.MessageBox(_(u'合并处理失败'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
					p = subprocess.Popen(r'taskkill /F /IM mklfs.exe', shell = True)
					statusBarStr = ""
					return
					
		filePaths = retrieve_file_paths(self.fw_images) 
		zipFile(combineFilePath, filePaths)
		fifferenceFile(fifferenceFilePath,fileList)
		statusBarStr = ""
		self.notebook_1.Enable()		### PETAR
		self.comOpen.Enable()			### PETAR
		wx.MessageBox(_(u'合并处理完成'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		p = subprocess.Popen(r'taskkill /F /IM mklfs.exe', shell = True)
		

	################### ENCRYPTION ADDED ####################
	def pyToMpy(self, input_path,backFlag=False):
		if '.py' not in input_path:			
			copyFile(input_path, self.mpy + '\\' + extractFileName(input_path)) 
			if backFlag:
				copyFile(input_path, self.backup + '\\' + extractFileName(input_path))
			return input_path
		if backFlag:
			output_path = self.backup + '\\' + extractFileName(input_path)
			output_path = output_path.rstrip('py') + 'mpy'
		else:
			output_path = self.mpy + '\\' + extractFileName(input_path)
			output_path = output_path.rstrip('py') + 'mpy'
		

		cmd2 = ['exes/mpy-cross/mpy-cross-amd64.exe', '-o', 
				output_path, 
				'-mno-unicode', 
				input_path]
		#print(cmd2)
		print('------------------mpy-cross-amd64.exe converting from py to mpy files: ------------------')
		p2 = runSubprocess(cmd2)
		p = p2.runner()
		
		if p.stdout.read() == b'':
			return output_path
		
		else:
			wx.MessageBox(extractFileName(input_path)+_(u'语法错误，无法加密'), 'Message', wx.YES_DEFAULT | wx.ICON_INFORMATION)	
			self.notebook_1.Enable()
			return
		#########################################################
	def initVersionJson(self,fw_name,jsonName):
		versionDict = {'fw_vision':fw_name}
		versionDict["module_model"] = "['EC100Y','EC600S']"
		versionDict["fw_hash_value"] = ""
		versionDict["fw_release_date"] = ""
		versionDict["fw_effective_date"] = ""
		versionDict["compile_parameters"] = ""
		versionDict["remark"] = "防呆下载参数"
		versionDict["reserve"] = ""
		
		self.writeJSON(versionDict,jsonName)
				
	
	def downloadFileCombineStart(self, event):
		global statusBarStr
		self.fw_fileName = extractFileName(self.firmwarePath.GetValue())
		if self.fw_fileName[-3:].lower() == "pac":
			wx.MessageBox(_(u'请选择正确的固件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			self.notebook_1.Enable()
			self.comOpen.Enable()
			return
		self.downloadFileCombine.SetFocus()	
		dlg = wx.DirDialog(self, _(u"选择文件夹"), style=wx.DD_DEFAULT_STYLE | wx.DD_NEW_DIR_BUTTON)
		statusBarStr = _(u"合并处理中")
		self.notebook_1.Enable(False)		## PETAR
		self.comOpen.Enable(False)			## PETAR
		if dlg.ShowModal() == wx.ID_OK:	
			T = threading.Thread(target=self.downloadFileCombineFunc,args=(dlg.GetPath(),))
			T.start()
		else:
			self.notebook_1.Enable()		## PETAR
			self.comOpen.Enable()			## PETAR
			# print(statusBarStr)
			statusBarStr = ""
	
	
	def downloadFileCombineFunc(self,dlgPath):
		global combineFilePath, fifferenceFilePath, listCheck_backup, statusBarStr
		'''
		if self.fw_fileName[-3:].lower()=="pac":
			wx.MessageBox(_(u'请选择正确的固件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			self.notebook_1.Enable()
			self.comOpen.Enable()
			return
		#ser, serProcessing, serProctype, serProceOnce, serProcTmpVar, protectFileStr,
		self.downloadFileCombine.SetFocus()	
		# if ser.isOpen() == False:
			# wx.MessageBox(_(u'请先打开串口'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			# return
		# defDir, defFile = '', ''	#default dir/ default file
		# dlg = wx.FileDialog(self, _(u'保存文件'), defDir, defFile, 'FW folder (*.zip)|*.zip', wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)
		# if dlg.ShowModal()==wx.ID_OK:
		dlg = wx.DirDialog(self, _(u"选择文件夹"), style=wx.DD_DEFAULT_STYLE | wx.DD_NEW_DIR_BUTTON)
		statusBarStr = _(u"合并处理中")
		self.notebook_1.Enable(False)		## PETAR
		self.comOpen.Enable(False)			## PETAR
		if dlg.ShowModal() == wx.ID_OK:	
		'''
		firmware_name, path_name_ls = self.configJSON()
		#combineFilePath = dlg.GetPath()
		if self.downloadFileBackup.GetValue():
			flag_backup_ls = [listCheck_backup[i] for i in range(self.downloadFileList.GetItemCount())]
			path_backup_ls = []
			[path_backup_ls.append(i) for i,j in zip(path_name_ls, flag_backup_ls) if j == True]
			if path_backup_ls != []:
				if not ifExist(self.backup):
					makeDir(self.backup)
			else:
				self.notebook_1.Enable()
				self.comOpen.Enable()
				wx.MessageBox(_(u'请选择需要备份的文件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				statusBarStr = ""
				return
		if not ifExist(self.mount):
			makeDir(self.mount)	
		if not ifExist(self.fw_images):
			makeDir(self.fw_images)
		if firmware_name != []:
			if not ifExist(firmware_name[0]):
				self.notebook_1.Enable()
				self.comOpen.Enable()
				wx.MessageBox(_(u'固件不存在'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				statusBarStr = ""
				return
			self.fw_fileName = extractFileName(firmware_name[0])
			makeCleanDir(self.fw_images)
			self.notebook_1.Enable()
			self.comOpen.Enable()
			unzipFile(self.firmwarePath.GetValue(), self.fw_images)
			
			# self.version_data = self.atGetVersion()
			# print(self.version_data)
			# print(self.fw_fileName[:10])
			# if self.fw_fileName[:10] != self.version_data:
				# wx.MessageBox(_(u'请确认固件包与模块型号一致'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				# statusBarStr = ""
				# return None
			if ifExist(self.fw_images.replace("/","\\") + "\\fw_version.json"):				
				temp_json_path_comb = self.readJSON(self.fw_images.replace("/","\\") + "\\fw_version.json")
				self.fw_fileName = temp_json_path_comb['fw_vision']
				print('内部版本号'+ str(self.fw_fileName))
			self.initVersionJson(self.fw_fileName,self.fw_images + "\\fw_version.json")
			
		else:
			self.notebook_1.Enable()
			self.comOpen.Enable()
			wx.MessageBox(_(u'请选择固件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			statusBarStr = ""
			return
		project_list = []	
		if path_name_ls != []:
			for i in path_name_ls:
				if extractFileName(i) == 'main.py':
					flag_main = i
					flag_index = path_name_ls.index(flag_main)	
					project_list.append(i)
			
			if len(project_list) > 0:					
				flag_ls2 = [listCheck[i] for i in range(self.downloadFileList.GetItemCount())]
				project_info = get_main_project_info(project_list[0])
				if flag_ls2[flag_index] == False:
					self.notebook_1.Enable()
					self.comOpen.Enable()
					wx.MessageBox(_(u'请确认合并的文件中是否包含main.py'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
					return None
				elif project_info == -1:
					self.notebook_1.Enable()
					self.comOpen.Enable()
					wx.MessageBox(_(u'请确认main.py中项目信息是否完整'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
					return None
				else:
					# 合并包路径
					combineFilePath = dlgPath + '\\' + project_info + '.zip'
					# 差分包路径
					fifferenceFilePath = dlgPath + '\\main.zip'
					#print(combineFilePath)
					makeCleanDir(self.mpy)
					makeCleanDir(self.mount)
					makeCleanDir(self.backup)
					self.notebook_1.Enable()
					self.comOpen.Enable()
					
			else:
				self.notebook_1.Enable()
				self.comOpen.Enable()
				wx.MessageBox(_(u'请确认合并的文件中是否包含main.py'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				return None
			
		# ENCRYPTION ADDED
			if self.downloadFileEncrypt.GetValue():
				serProcTmpVar = self.mpy + '\\'
				# list of File does not exist
				unknowFileList = []
				for i in path_name_ls:
					if not ifExist(i):
						unknowFileList.append(i)
				for i in unknowFileList:
					path_name_ls.remove(i)
				if unknowFileList != []:
					self.notebook_1.Enable()
					self.comOpen.Enable()
					wx.MessageBox(_(u'文件不存在'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)	
				if not ifExist(self.mpy):
					makeDir(self.mpy)
				else:
					makeCleanDir(self.mpy)
					
				# generate checksum.json
				if self.downloadFileBackup.GetValue():
					# Removes files that do not exist
					for i in unknowFileList:
						path_backup_ls.remove(i)
					# main.py does not require encryption
					for i in path_backup_ls:
						if extractFileName(i) == 'main.py':
							break
					path_backup_ls.remove(i)
					copyFile(i, self.backup + '\\' + extractFileName(i))
					copyFile(i, self.mpy + '\\' + extractFileName(i))								
					# Encrypted backup file
					backup_name_ls = []
					for i in path_backup_ls:
						a = self.pyToMpy(i,True)
						if a:
							backup_name_ls.append(a)
					checkSum(backup_name_ls,self.backup + '\\')
				# Encrypted merge file
				for i in path_name_ls:
					if extractFileName(i) == 'main.py':
						break
				path_name_ls.remove(i)
				copyFile(i, self.mpy + '\\' + extractFileName(i))
				
				# exclude unchecked files from the list
				flag_ls = [listCheck[i] for i in range(self.downloadFileList.GetItemCount())]
				flag_name_ls = []
				[flag_name_ls.append(i) for i,j in zip(path_name_ls, flag_ls) if j == True]
				for i in flag_name_ls:
					a = self.pyToMpy(i)
					if a:
						path_name_ls.append(a)
				
				if flag_name_ls == []:
					self.notebook_1.Enable()
			else:
				flag_encryption_unchecked = [listCheck[i] for i in range(self.downloadFileList.GetItemCount())]
				flag_name_ls = []
				[flag_name_ls.append(i) for i,j in zip(path_name_ls, flag_encryption_unchecked) if j == True]
				serProcTmpVar = self.mount + '\\'										
				[copyFile(src, self.mount + '\\' + extractFileName(src)) for src in flag_name_ls]
				if self.downloadFileBackup.GetValue():
					[copyFile(src, self.backup + '\\' + extractFileName(src)) for src in path_backup_ls]
					checkSum(path_backup_ls,self.backup + '\\')
			self.mklfs(flag_name_ls)
			# Backup files that need to be protected before merging
			# 合并前备份文件功能
			'''
			for i in protectFile:
				protectFileStr = i
				serProcessing = True	#continue "ls" operation
				serProctype = "protectFile"
				serProceOnce = False
				time.sleep(1)
			'''
			
			
			'''
			[copyFile(src, self.mount + '\\' + extractFileName(src)) for src in path_name_ls]
			self.mklfs()
			time.sleep(0.1)
			filePaths = retrieve_file_paths(self.fw_images) 
			zipFile(dlg.GetPath(), filePaths)
			'''

		else:
			self.notebook_1.Enable()
			self.comOpen.Enable()
			wx.MessageBox(_(u'请先选择文件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			return				
		
	
	def script_download(self):
		global ser, listCheck,statusBarStr, protectFile, serProcessing, serProctype, serProceOnce, serProcTmpVar, serLastRecvData, serLastRecvTime
		print("list file")
		serProcessing = True	#continue "ls" operation
		serProctype = "ls"
		serProceOnce = False
		serProcTmpVar = None
		
		time.sleep(1)
		
		serProcessing = True
		serProctype = "batchDownload"
		
		#if not self.firmwarePath.GetValue():
		#		wx.MessageBox(_(u'请先选择文件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		#		return
		# list file paths from JSON
		firmware_name, path_name_ls = self.configJSON()
		# elist of booleans - checked files on the list = True
		flag_ls = [listCheck[i] for i in range(self.downloadFileList.GetItemCount())]
		
		# exclude unchecked files from the list
		flag_name_ls = []
		[flag_name_ls.append(i) for i,j in zip(path_name_ls, flag_ls) if j == True]
		# File does not exist
		totalFileSize = 0
		unknowFileList = []
		for i in flag_name_ls:
			if not ifExist(i):
				unknowFileList.append(i)
		for i in unknowFileList:
			flag_name_ls.remove(i)
		if unknowFileList != []:
			self.notebook_1.Enable()
			self.comOpen.Enable()
			wx.MessageBox(_(u'文件不存在'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		#flag_name_ls,remove_comments_tmp_path = remove_comments(flag_name_ls)
		for i in flag_name_ls:
				totalFileSize += getFileSize(i)
				print(getFileSize(i))
			
		if totalFileSize > maxFileSize:
			self.notebook_1.Enable()
			self.comOpen.Enable()
			wx.MessageBox(_(u'选择小于5MB的文件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			return			
		self.downloadFileStart.Enable(False)
		self.notebook_1.Enable(False)
		self.comOpen.Enable(False)
		# try:
			# if ser.isOpen() == False:
				# self.waitToPort(self.pCfg["firmware"]["vid_pid_dwload"])
				# comport = self.comPortNumber(self.pCfg["firmware"]["vid_pid_work"],
											# self.pCfg["firmware"]["USB_Serial_Device"])
				# ser.port = comport
				# ser.baudrate = 115200
				# ser.timeout = 1
				# ser.open()
		# except:
			# pass
		try:
			ser.reset_input_buffer()
		except:
			wx.MessageBox(_(u'试图使用未打开的端口。请再试一次。注意FW已经下载'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			self.downloadProgress.SetValue(0)						
			self.downloadFileStart.Enable()
			self.notebook_1.Enable()
			self.comOpen.Enable()

		# if self.downloadFileStart.GetLabel() == _(u"下载固件+脚本"):
			# rawReplEnd = b"raw REPL; CTRL-B to exit"
			# while rawReplEnd not in ser.read_until(rawReplEnd):
				# ser.write(b"\r\x01")
				# time.sleep(0.25)
		# else:
			# ser.write(b"\r\x01")
		
		
		fOper = fileOperation()

		# list files from module
		#module_ls = fOper.fs_ls()
		module_ls = self.getItemList(self.modFileTree)

		# provide not removing of protected files
		[module_ls.remove(i) for i in protectFile if i in module_ls]
		
		print('THIS IS MODULE LIST: ', module_ls)
		
		# remove files from module
		[fOper.fs_remove(i) for i in module_ls]

		# add files to module
		
		tmpFileSize = 0
		pub.subscribe(self.updateProgress, "updateProgress")
		for i in flag_name_ls:
			try:
				fOper.fs_download(tmpFileSize,totalFileSize,i)
				tmpFileSize += getFileSize(i)
			except:
				self.downloadFileStart.Enable()
				self.notebook_1.Enable()
				self.comOpen.Enable()
				self.downloadProgress.SetValue(0)
				flag_script_download_failed = True
		statusBarStr = ""
		
		# [BUG36] Content of files downloaded at the module, instead of comments contains newlines
		#shutil.rmtree(remove_comments_tmp_path)
		
		#ser.write(b"\r\x02")

		# ser.close()

		print('PASS')
		#wx.MessageBox(_(u'脚本下载完成'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		self.downloadFileStart.Enable()
		self.notebook_1.Enable()
		self.comOpen.Enable()
		serProcessing = False
		serProctype = "batchDownload"
		
		print("list file")
		serProcessing = True	#continue "ls" operation
		serProctype = "ls"
		serProceOnce = False
		serProcTmpVar = None
	
		
	def fw_download(self, download_name,fw_name):
		global flag_download_start
		self.downloadFileStart.Enable(False)
		self.comOpen.Enable(False)
		self.notebook_1.Enable(False)		
		# if not self.firmwarePath.GetValue():
				# wx.MessageBox(_(u'请选择固件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				# return
		# progressbar
		pub.subscribe(self.updateProgress, "updateProgress")
		comport = self.comPortReturn()
		# return correct code and msg
		print(comport)
		if comport == None:	
			self.downloadFileStart.Enable()
			self.comOpen.Enable()
			self.notebook_1.Enable()																				   
			return
		if self.fw_fileName[-3:].lower()=="pac":
			cmd4 = [download_name, '-pac',fw_name, '-port', comport]
			print('------------------unisoc downloading upgrade package: ------------------')
			downloadProcess = 'Downloading...'
		else:
			cmd4 = [download_name, '-p',
				comport, '-a', '-q', '-r', '-s', '115200',
				fw_name]
			print('------------------adownload downloading factory package: ------------------')
			downloadProcess = '"progress" :'
		flag_download_start = True
		print(cmd4)
						
		p4 = runCommand(cmd4, downloadProcess)
		#shutil.rmtree(os.path.dirname(fw_name))
		return

	# TimeMonitor for fw 
	def downloadTimeMonitor(self):
		global timeMonitor, statusBarStr, flag_download_failed
		tmp = timeMonitor
		i = 0
		while True:
			if tmp == timeMonitor:
				i += 1
			else:
				i = 0
			tmp = timeMonitor
			time.sleep(1)
			if i > 30:
				p = subprocess.Popen(r'taskkill /F /IM adownload.exe',shell = True)
				p = subprocess.Popen(r'taskkill /F /IM ResearchDownload.exe',shell = True)
				self.downloadProgress.SetValue(0)
				flag_download_failed = True
				wx.MessageBox(_(u'下载固件失败，请检查模块和固件包'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				self.downloadFileStart.Enable()
				self.notebook_1.Enable(True)
				self.comOpen.Enable()
				break
			if int(timeMonitor) in (99,100):
				break

		timeMonitor = 0
		statusBarStr = ""
		return

	def compareVersion(self,temp_json_path):			
		self.version_data = self.atGetVersion()
		print(self.version_data)
		if self.fw_fileName[:10] != self.version_data:
			#print(self.tmp_path.replace("/","\\") + "\\images\\fw_version.json")
			if self.version_data is None:
				return True
			else:
				if ifExist(self.tmp_path.replace("/","\\") + "\\images\\fw_version.json"):
					# Determine if the file contents are correct					
					temp_json_path = self.readJSON(self.tmp_path.replace("/","\\") + "\\images\\fw_version.json")
					if self.version_data in temp_json_path['fw_vision']:
						return True												
					else:
						return False												
				else:
					return False										
		else:
			return True			
	def rdaFwDownload(self):
		self.tmp_path = tempfile.mkdtemp()
		shutil.copyfile(self.firmwarePath.GetValue(), self.tmp_path.replace("/","\\") + "\\" + self.fw_fileName)
		rdaFile_list = glob.glob(os.path.join(PROJECT_ABSOLUTE_PATH + "\\exes\\rda\\",'*'))
		for i in rdaFile_list:
			# print(i)
			shutil.copy(i,self.tmp_path.replace("/","\\"))
		# print(self.tmp_path.replace("/","\\") + "\\rda\\")
		
		statusBarStr = _(u"下载固件中请勿退出软件")	
		T = threading.Thread(target=self.fw_download,args=(self.tmp_path.replace("/","\\") + "\\CmdDloader.exe",self.tmp_path.replace("/","\\") + "\\" + self.fw_fileName))
		T.start()
		
		
	def asrFwDownload(self):
		self.tmp_path = tempfile.mkdtemp()
		self.tempZip_filename = binToZip(self.fw_fileName)
		print("临时文件名"+self.tempZip_filename)
		shutil.copyfile(self.firmwarePath.GetValue(), self.tmp_path.replace("/","\\") + "\\" + self.tempZip_filename)
		shutil.copyfile(PROJECT_ABSOLUTE_PATH + "\\exes\\aboot\\adownload.exe", self.tmp_path.replace("/","\\") + "\\adownload.exe")
		unzipFile(self.tmp_path.replace("/","\\") + "\\" + self.tempZip_filename, self.tmp_path.replace("/","\\") + "\\images")
		if checkZipFile(self.tmp_path.replace("/","\\") + "\\images"):
			# Get the module version through the AT command
			if self.compareVersion:
				statusBarStr = _(u"下载固件中请勿退出软件")
				T = threading.Thread(target=self.fw_download,args=(self.tmp_path.replace("/","\\") + "\\adownload.exe",self.tmp_path.replace("/","\\") + "\\" + self.tempZip_filename))
				T.start()
			else:
				wx.MessageBox(_(u'请确认固件包版本与模块版本是否一致'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		else:
			wx.MessageBox(_(u'检查固件zip包是否未解压,请解压后重试'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		
		
	def downloadFileStartFunc(self, event):
		global ser, statusBarStr
		if self.downloadFileStart.GetLabel() == _(u"下载脚本"):
			if self.projectList.GetSelection() == -1:
				wx.MessageBox(_(u'请先创建或者选择一个项目'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				return
			if ser.isOpen():
				# print(serLastRecvData,serLastRecvTime)
				if serLastRecvData.decode("utf-8", errors="ignore").endswith(">>> ") or serLastRecvData == b"" or serLastRecvTime==0:
					pass
				else:
					wx.MessageBox(_(u'Python 代码运行输出中,请检查交互是否有代码运行中\r\n如需停止运行，请等待程序结束，或者重新刷写固件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
					return
			else:
				wx.MessageBox(_(u'请先打开串口'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				return
			# if flag_block_download == True:
				# wx.MessageBox(_(u'main.py 正在运行中'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			
			T = threading.Thread(target=self.script_download)
			T.start()
			self.notebook_1.Enable(False)	### PETAR
			self.comOpen.Enable(False) 		## PETAR
		elif self.downloadFileStart.GetLabel() == _(u"下载固件"):
			dlg  = wx.MessageBox(_(u"下载过程中请勿退出软件"), _(u"提示"), wx.YES_DEFAULT|wx.CANCEL|wx.ICON_QUESTION)
			if dlg == wx.OK:
				if ifExist(self.firmwarePath.GetValue()):
					# Generate temP temporary files
					self.fw_fileName = extractFileName(self.firmwarePath.GetValue())
					if self.fw_fileName[-3:].lower()=="pac":
						self.rdaFwDownload()
					else:
						self.asrFwDownload()
				else:
					wx.MessageBox(_(u'固件不存在'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			else:
				return
		# elif self.downloadFileStart.GetLabel() == _(u"下载固件+脚本"):
			# if ifExist(self.firmwarePath.GetValue()):
				# self.fw_download(self.firmwarePath.GetValue())				
			# else:
				# wx.MessageBox(_(u'文件不存在'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)

	def OnDownloadContextMenu(self, event):
		self.Bind(wx.EVT_MENU, self.OnDownloadPopupMenu,id=0,id2=1)
		menu = wx.Menu()
		item = wx.MenuItem(menu, 0, _(u"下载脚本"))
		item.Enable(enable = True) 
		menu.Append(item)
		item = wx.MenuItem(menu, 1, _(u"下载固件"))
		item.Enable(enable = True) 
		menu.Append(item)
		#item = wx.MenuItem(menu, 2, _(u"下载固件+脚本"))
		#item.Enable(enable = True) 
		#menu.Append(item)
		self.downloadFileMore.PopupMenu(menu)
		menu.Destroy()

	def OnDownloadPopupMenu(self, event):
		if event.GetId()==0:
			self.downloadFileStart.SetLabel(_(u"下载脚本"))
		elif event.GetId()==1:
			self.downloadFileStart.SetLabel(_(u"下载固件"))
		elif event.GetId()==2:
			self.downloadFileStart.SetLabel(_(u"下载固件+脚本"))

	def RemoveItems(self):
		self.index = 0
		self.firmwarePath.SetValue('')
		self.downloadFileList.DeleteAllItems()

	def projectCreatFunc(self, event):
		self.projectCreat.SetFocus()
		dlg = wx.TextEntryDialog(self, _(u"输入项目名称:"), _(u"项目名称"), '', wx.OK|wx.CANCEL)
		if dlg.ShowModal() == wx.ID_OK:
			self.RemoveItems()
			if dlg.GetValue() == "":
				wx.MessageBox(_(u'项目名称不可为空'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				return None
			if self.projectList.FindString(dlg.GetValue(), caseSensitive = True) != -1:
				wx.MessageBox(_(u'同名项目已存在'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				return None
			if len(dlg.GetValue()) > 20:
				wx.MessageBox(_(u'项目名称长度不可超过20'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				return None
			self.projectList.Append(dlg.GetValue())
			self.projectList.SetSelection(self.projectList.GetCount()-1) # find better solution
			if not ifExist(self.project):
				makeDir(self.project)
			jsonName = self.project + '\\' + dlg.GetValue() + '.json'
			self.writeJSON(self.config, jsonName)

	def projectDeleteFunc(self, event):
		deleted_item = self.projectList.GetSelection()
		projectName = self.projectList.GetString(deleted_item)
		self.projectList.Delete(deleted_item)
		os.remove(self.project + "\\" + projectName + ".json")
		self.RemoveItems()
		if self.projectList.GetCount() > 0:
			try:
				self.projectList.SetSelection(deleted_item)
			except:
				self.projectList.SetSelection(deleted_item - 1)
			firmware_name, path_name_ls = self.configJSON()
			self.RemoveItems()
			if firmware_name != []:
				self.firmwarePath.SetValue(firmware_name[0])
			if path_name_ls != []:
				for path in path_name_ls:
					self.ListCtrlInsertItem(path)
					self.index += 1

	def firmwareBrowserFunc(self, event):
		self.firmwareBrowser.SetFocus()
		defDir, defFile = '', ''	#default dir/ default file
		dlg = wx.FileDialog(self, _(u'打开文件'), defDir, defFile, 'ASR FW files (*.bin)|*.bin|ASR FW files (*.zip)|*.zip|unisoc FW files(*.pac)|*.pac',wx.FD_OPEN | wx.FD_FILE_MUST_EXIST)
		if self.projectList.GetSelection() == -1:
			wx.MessageBox(_(u'请先创建或者选择一个项目'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			return
		if dlg.ShowModal()==wx.ID_OK:
			self.firmwarePath.SetValue(dlg.GetPath())
			self.editJSON(dlg.GetPath(), "firmware_name")
	
	def OnSelection(self, event):
		firmware_name, path_name_ls = self.configJSON()
		self.RemoveItems()
		if firmware_name != []:
			self.firmwarePath.SetValue(firmware_name[0])
		if path_name_ls != []:
			for path in path_name_ls:
				self.ListCtrlInsertItem(path)
				self.index += 1

	def readJSONonSelection(self):
		index = self.projectList.GetSelection()
		projectName = self.projectList.GetString(index)
		self.file_path = self.project + '\\' + projectName + '.json'

		return self.readJSON(self.file_path)

	def	ListCtrlInsertItem (self, dlgGetPath):
		global listCheck
		self.downloadFileList.InsertItem(self.index, "🔘")
		self.downloadFileList.SetItem(self.index, 1, "🔘")
		listCheck[self.index]=True
		listCheck_backup[self.index]=True
		self.myevthandler = MyEventHandler(self.downloadFileList)
		self.downloadFileList.PushEventHandler(self.myevthandler)									
		self.downloadFileList.SetItem(self.index, 2, dlgGetPath)											
		self.downloadFileList.SetItem(self.index, 3, '{:.1f}'.format(getFileSize(dlgGetPath) /1024))
		
		
		
	def configJSON(self):
		config = self.readJSONonSelection()
		firmware_name = config['firmware_name']
		path_name_ls = config['path_name']

		return firmware_name, path_name_ls

	def editJSON(self, dlgPath, firmware_path, action = 'add'):
		config = self.readJSONonSelection()
		if action == 'add':
			if firmware_path == 'firmware_name':
				config[firmware_path].clear()
			config[firmware_path].append(dlgPath)
		elif action == 'remove':
			try:
				config[firmware_path].pop(dlgPath)
			except:
				wx.MessageBox(_(u'请先选择文件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		elif action == 'clear':
			config[firmware_path].clear()
		self.writeJSON(config, self.file_path)

	def downloadFileAddFunc(self, event):  # wxGlade: qpyTools.<event_handler>
		self.downloadFileAdd.SetFocus()
		defDir, defFile = '', ''	#default dir/ default file
		dlg = wx.FileDialog(self, _(u'打开文件'), defDir, defFile, 'All files (*.*)|*.*', wx.FD_OPEN | wx.FD_FILE_MUST_EXIST | wx.FD_MULTIPLE)	

		if self.projectList.GetSelection() == -1:																			# appears 4 times, try to replace with function
			wx.MessageBox(_(u'请先创建或者选择一个项目'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			return
		if dlg.ShowModal()==wx.ID_OK:
			self.fileAdd(dlg.GetPaths())

	def fileAdd(self, fileAddList):
		count = self.downloadFileList.GetItemCount()
		items = [self.downloadFileList.GetItem(row, col=2).GetText() for row in range(count)]
		total_size = 0
		total_size_lst = [float(self.downloadFileList.GetItem(row, col=3).GetText()) for row in range(count)]
		for prj_file_sz in total_size_lst:
			total_size += prj_file_sz
		# multiple addition allowed
		downloadScriptList = []
		maxFileSizeFlag = False
		for dlgPath in fileAddList:
			total_size += getFileSize(dlgPath) / 1000
			print(total_size)
			# block duplicates
			if dlgPath in items:
				downloadScriptList.append(dlgPath)
			# block files greater than 5MB
			elif getFileSize(dlgPath) > maxFileSize:
				maxFileSizeFlag = True
			elif int(total_size * 1000) > maxFileSize:
				wx.MessageBox(_(u'选择小于5MB的文件'), _(u'提示'), wx.OK | wx.ICON_ERROR)
				return
			else:
				self.ListCtrlInsertItem(dlgPath)
				self.index += 1
				self.editJSON(dlgPath, "path_name")
		fileStr = ""
		if downloadScriptList != []:
			for i in downloadScriptList:
				fileStr += (repr(extractFileName(i).encode("utf-8", errors="ignore"))[2:-1]+"、")
			wx.MessageBox((fileStr[0:-1] + _(u'已存在，请勿重复选择')), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		if maxFileSizeFlag:
			wx.MessageBox(_(u'选择小于5MB的文件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		return

	def GetSelectedItems(self, listCtrl):
		selection = []
		index = listCtrl.GetFirstSelected()
		if index > -1:
			selection.append(index)
		while len(selection) != listCtrl.GetSelectedItemCount():
			index = listCtrl.GetNextSelected(index)
			selection.append(index)

		return selection

	def downloadFileRmFunc(self, event):
		if self.projectList.GetSelection() == -1:
			wx.MessageBox(_(u'请先创建或者选择一个项目'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			return
		# remove = self.downloadFileList.GetFirstSelected()
		# if remove > -1:
		#	 self.index -= 1 # GetSelectedItemCount
		#	 self.downloadFileList.DeleteItem(remove) #GetNextSelected #GetFirstSelected
		#	 self.editJSON(remove, 'path_name', 'remove')
		# remove = self.downloadFileList.GetFirstSelected()
		# if remove > -1:
		#	 self.index -= 1 # GetSelectedItemCount
		#	 self.downloadFileList.DeleteItem(remove) #GetNextSelected #GetFirstSelected
		#	 self.editJSON(remove, 'path_name', 'remove')
		selection = self.GetSelectedItems(self.downloadFileList)
		i = 0
		for remove in selection:
			remove -= i
			i += 1
		# remove = self.downloadFileList.GetFirstSelected()
			if remove > -1:
				self.index -= 1 # GetSelectedItemCount
				self.downloadFileList.DeleteItem(remove) #GetNextSelected #GetFirstSelected
				self.editJSON(remove, 'path_name', 'remove')

	def downloadFileCleanFunc(self, event):
		if self.projectList.GetSelection() == -1:
			wx.MessageBox(_(u'请先创建或者选择一个项目'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			return
		self.downloadFileList.DeleteAllItems()
		self.index = 0
		self.editJSON(None, 'path_name', 'clear')

	def updateProgress(self, arg1):
		global statusBarStr, flag_download_finished, flag_download_start
		self.downloadProgress.SetValue(int(arg1))		
		statusBarStr = "Download progress: {:.2f}%".format(float(arg1))		# [BUG1] 2 decimal places
		if int(arg1) == 100:
			time.sleep(2)
			if self.downloadFileStart.GetLabel() == "下载固件":
				pub.unsubscribe(self.updateProgress, "updateProgress")
				flag_download_finished = True
				flag_download_start = False
				self.waitToPort(self.pCfg["firmware"]["vid_pid_work"], 
								self.pCfg["firmware"]["USB_Serial_Device"])
				self.downloadFileStart.Enable()
				self.notebook_1.Enable()
				self.comOpen.Enable()				
				wx.MessageBox(_(u'固件下载结束'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				self.downloadProgress.SetValue(0)
				# Delete temporary files
				shutil.rmtree(self.tmp_path)
				# get info after fw download success
				get_info_func = getUsageInfo({"trigger": 1,"project_count": self.projectList.GetCount(),"QPYcom_version": versionGlobal})				
			else:
				pub.unsubscribe(self.updateProgress, "updateProgress")
				flag_download_finished = True
				flag_download_start = False
				# self.waitToPort(self.pCfg["firmware"]["vid_pid_work"], 
								# self.pCfg["firmware"]["USB_Serial_Device"])
				self.downloadFileStart.Enable()
				self.notebook_1.Enable()
				self.comOpen.Enable()
				wx.MessageBox(_(u'下载结束'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				self.downloadProgress.SetValue(0)			
				# tSerialDet = serialDet()     # Why create a new thread
				# tSerialDet.setDaemon(True)	#set as deamon, stop thread while main frame exit
				# tSerialDet.start()
			flag_download_finished = False				
			return

	def dragAndDrop(self, arg1):
		if self.projectList.GetSelection() == -1: # appears 4 times, try to replace with function																			
			wx.MessageBox(_(u'请先创建或者选择一个项目'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			return
		self.fileAdd(arg1)
	def howGetFirmwareFunc(self, event):
		webbrowser.open("https://python.quectel.com/download", new = 2)
			
	## SLOBODAN ##

	def __set_properties(self):
		# begin wxGlade: qpyTools.__set_properties
		self.SetTitle("QPYcom_V" + versionGlobal)
		_icon = wx.NullIcon
		_icon.CopyFromBitmap(wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\quectel.ico", wx.BITMAP_TYPE_ICO))
		self.SetIcon(_icon)
		self.SetBackgroundColour(wx.NullColour)
		self.SetForegroundColour(wx.Colour(0, 0, 0))
		self.statusBar.SetStatusWidths([160, -1, 155])
		
		# statusbar fields
		statusBar_fields = [_(u"  欢迎使用 QuecPython"), _(u" 当前状态: 就绪..."), " 0000-00-00 00:00:00"]
		for i in range(len(statusBar_fields)):
			self.statusBar.SetStatusText(statusBar_fields[i], i)
		self.toolBar.Realize()
		self.comSelector.SetMinSize((260, 28))
		self.comSelector.SetToolTip("Uart List")
		self.comBaud.SetMinSize((100, 28))
		self.comBaud.SetSelection(8)
		self.comOpen.SetMinSize((105, 35))
		self.comOpen.SetFocus()
		self.comOpen.SetBitmap(wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\openCOM.ico", wx.BITMAP_TYPE_ICO))
		self.comSettingMore.SetMinSize((22, 35))
		self.localFilePathGoUp.SetMinSize((29, 29))
		self.localFilePathReFresh.SetMinSize((29, 29))
		self.localFilePathReFresh.SetFont(wx.Font(12, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, 0, "Microsoft YaHei UI"))
		self.localFilePathGo.SetMinSize((29, 29))
		self.localFilePathGo.SetFont(wx.Font(18, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, 0, ""))
		self.localFileList.AppendColumn(_(u"文件名"), format=wx.LIST_FORMAT_LEFT, width=-1)
		self.localFileList.AppendColumn(_(u"大小"), format=wx.LIST_FORMAT_LEFT, width=110)
		self.localFileList.AppendColumn(_(u"类型"), format=wx.LIST_FORMAT_LEFT, width=90)
		self.localFileList.AppendColumn(_(u"修改日期"), format=wx.LIST_FORMAT_LEFT, width=170)
		self.modFileRefresh.SetMinSize((29, 29))
		self.modFileRefresh.SetFont(wx.Font(12, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, 0, "Microsoft YaHei UI"))
		self.modFileExec.SetMinSize((29, 29))
		self.modFileAdd.SetMinSize((29, 29))
		self.modFileRm.SetMinSize((29, 29))
		self.modFileClean.SetMinSize((29, 29))
		self.fileSplitter.SetMinimumPaneSize(20)
		self.projectCreat.SetMinSize((93, 30))
		self.projectDelete.SetMinSize((93, 30))
		self.firmwareBrowser.SetMinSize((93, 30))
		self.howGetFirmware.SetMinSize((30, 30))
		self.downloadFileList.AppendColumn(_(u"选择"), format=wx.LIST_FORMAT_LEFT, width=70)
		self.downloadFileList.AppendColumn(_(u"备份"), format=wx.LIST_FORMAT_LEFT, width=70)
		self.downloadFileList.AppendColumn(_(u"路径"), format=wx.LIST_FORMAT_LEFT, width=700)
		self.downloadFileList.AppendColumn(_(u"大小 [KB]"), format=wx.LIST_FORMAT_LEFT, width=-1)
		
		self.downloadFileAdd.SetMinSize((35, 30))
		self.downloadFileRm.SetMinSize((35, 30))
		self.downloadFileClean.SetMinSize((35, 30))
		self.downloadFileEncrypt.SetValue(1)
		# self.downloadFileCompress.SetValue(1)
		self.downloadFileBackup.SetValue(0)
		self.downloadFileStart.SetMinSize((125, 30))
		self.downloadFileMore.SetMinSize((20, 30))
		self.downloadFileCombine.SetMinSize((80, 30))
		self.label_7.Enable(False)
		self.autoSaveLogMaxItem.SetMinSize((105, 30))
		self.autoSaveLogMaxItem.Enable(False)
		self.label_8.Enable(False)
		self.autoSaveLogMaxSize.SetMinSize((105, 30))
		self.autoSaveLogMaxSize.Enable(False)
		self.codeEditorPathText.SetMinSize((520, 30))
		self.codeEditorPathText.Enable(False)
		self.srcEditorBrowseBtn.SetMinSize((22, 30))
		self.srcEditorBrowseBtn.Enable(False)
		self.label_13.Enable(False)
		self.codeEditorParam.SetMinSize((70, 30))
		self.codeEditorParam.Enable(False)
		self.label_14.Enable(False)
		self.comParity.SetMinSize((90, 28))
		self.comParity.Enable(False)
		self.comParity.SetSelection(0)
		self.label_15.Enable(False)
		self.comDatabit.SetMinSize((60, 28))
		self.comDatabit.Enable(False)
		self.comDatabit.SetSelection(3)
		self.label_16.Enable(False)
		self.comStopbits.SetMinSize((60, 28))
		self.comStopbits.Enable(False)
		self.comStopbits.SetSelection(0)
		self.label_17.Enable(False)
		self.comFlowControl.Enable(False)
		self.comFlowControl.SetSelection(0)
		self.mpycPathText.SetMinSize((520, 30))
		self.mpycPathText.Enable(False)
		self.mpycBrowser.SetMinSize((22, 30))
		self.mpycBrowser.Enable(False)
		self.openConfigFile.SetMinSize((300, 30))
		self.openConfigFile.Enable(False)
		self.fontButton.SetMinSize((300, 30))
		self.fontButton.Enable(False)
		self.configConfirm.SetMinSize((99, 30))
		self.configReset.SetMinSize((99, 30))
		self.configCancel.SetMinSize((99, 30))
		# end wxGlade

	def __do_layout(self):
		# begin wxGlade: qpyTools.__do_layout
		box_sizer_1 = wx.BoxSizer(wx.VERTICAL)
		sizer_23 = wx.BoxSizer(wx.VERTICAL)
		sizer_31 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_32 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_25 = wx.BoxSizer(wx.VERTICAL)
		grid_sizer_1 = wx.FlexGridSizer(11, 2, 0, 0)
		sizer_38 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_37 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_36 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_35 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_34 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_33 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_27 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_26 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_24 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_7 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_6 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_3 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_4 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_15 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_18 = wx.StaticBoxSizer(wx.StaticBox(self.notebook_1_pane_3, wx.ID_ANY, _(u" 下载 ")), wx.HORIZONTAL)
		sizer_19 = wx.BoxSizer(wx.VERTICAL)
		sizer_22 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_21 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_20 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_16 = wx.StaticBoxSizer(wx.StaticBox(self.notebook_1_pane_3, wx.ID_ANY, _(u" 项目 ")), wx.VERTICAL)
		sizer_17 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_9 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_13 = wx.BoxSizer(wx.VERTICAL)
		sizer_14 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_10 = wx.BoxSizer(wx.VERTICAL)
		sizer_12 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_8 = wx.GridSizer(1, 1, 0, 0)
		sizer_1 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_2 = wx.BoxSizer(wx.HORIZONTAL)
		box_sizer_1.Add((20, 3), 0, 0, 0)
		sizer_2.Add((0, 20), 0, 0, 0)
		sizer_2.Add(self.label_4, 0, wx.ALL, 6)
		sizer_2.Add(self.comSelector, 0, wx.ALL, 3)
		sizer_2.Add((20, 20), 0, 0, 0)
		sizer_2.Add(self.label_3, 0, wx.ALL, 6)
		sizer_2.Add(self.comBaud, 0, wx.ALL, 3)
		sizer_2.Add((10, 20), 0, 0, 0)
		sizer_2.Add(self.comOpen, 0, 0, 0)
		sizer_2.Add(self.comSettingMore, 0, 0, 0)
		sizer_1.Add(sizer_2, 1, 0, 0)
		bitmap_2 = wx.StaticBitmap(self, wx.ID_ANY, wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\Quectel-logo.ico", wx.BITMAP_TYPE_ICO))
		sizer_1.Add(bitmap_2, 0, wx.ALL, 0)
		sizer_1.Add((15, 20), 0, 0, 0)
		box_sizer_1.Add(sizer_1, 0, wx.EXPAND, 0)
		box_sizer_1.Add((20, 0), 0, 0, 0)
		sizer_8.Add(self.stc, 1, wx.EXPAND, 0)
		self.notebook_1_pane_1.SetSizer(sizer_8)
		sizer_10.Add((20, 5), 0, 0, 0)
		sizer_12.Add(self.localFilePathGoUp, 0, 0, 0)
		sizer_12.Add((3, 20), 0, 0, 0)
		sizer_12.Add(self.localFilePathReFresh, 0, 0, 0)
		sizer_12.Add((3, 20), 0, 0, 0)
		sizer_12.Add(self.localFilePath, 1, 0, 0)
		sizer_12.Add((3, 20), 0, 0, 0)
		sizer_12.Add(self.localFilePathGo, 0, 0, 0)
		sizer_12.Add((3, 20), 0, 0, 0)
		sizer_10.Add(sizer_12, 0, wx.EXPAND, 0)
		sizer_10.Add((20, 5), 0, 0, 0)
		sizer_10.Add(self.localFileList, 1, wx.ALL | wx.EXPAND, 0)
		self.window_1_pane_1.SetSizer(sizer_10)
		sizer_13.Add((20, 5), 0, 0, 0)
		sizer_14.Add((2, 20), 0, 0, 0)
		sizer_14.Add(self.modFileRefresh, 0, 0, 0)
		sizer_14.Add((5, 20), 0, 0, 0)
		sizer_14.Add(self.modFileExec, 0, 0, 0)
		sizer_14.Add((5, 20), 0, 0, 0)
		sizer_14.Add(self.modFileAdd, 0, 0, 0)
		sizer_14.Add((5, 20), 0, 0, 0)
		sizer_14.Add(self.modFileRm, 0, 0, 0)
		sizer_14.Add((5, 20), 0, 0, 0)
		sizer_14.Add(self.modFileClean, 0, 0, 0)
		sizer_13.Add(sizer_14, 0, wx.EXPAND, 0)
		sizer_13.Add((20, 5), 0, 0, 0)
		sizer_13.Add(self.modFileTree, 1, wx.EXPAND, 0)
		self.window_1_pane_2.SetSizer(sizer_13)
		self.fileSplitter.SplitVertically(self.window_1_pane_1, self.window_1_pane_2)
		sizer_9.Add(self.fileSplitter, 1, wx.EXPAND, 0)
		self.notebook_1_pane_2.SetSizer(sizer_9)
		sizer_16.Add(self.projectList, 1, wx.EXPAND, 0)
		sizer_16.Add((20, 5), 0, 0, 0)
		sizer_17.Add(self.projectCreat, 0, 0, 0)
		sizer_17.Add((20, 20), 0, 0, 0)
		sizer_17.Add(self.projectDelete, 0, 0, 0)
		sizer_16.Add(sizer_17, 0, 0, 0)
		sizer_15.Add(sizer_16, 0, wx.ALL | wx.EXPAND, 3)
		sizer_19.Add((20, 3), 0, 0, 0)
		sizer_20.Add((2, 20), 0, 0, 0)
		label_2 = wx.StaticText(self.notebook_1_pane_3, wx.ID_ANY, _(u"固件: "))
		sizer_20.Add(label_2, 0, wx.ALL, 4)
		sizer_20.Add((2, 20), 0, 0, 0)
		sizer_20.Add(self.firmwarePath, 1, 0, 0)
		sizer_20.Add((5, 20), 0, 0, 0)
		sizer_20.Add(self.firmwareBrowser, 0, 0, 0)
		sizer_20.Add(self.howGetFirmware, 0, 0, 0)
		sizer_20.Add((2, 20), 0, 0, 0)
		sizer_19.Add(sizer_20, 0, wx.EXPAND, 0)
		sizer_19.Add((20, 5), 0, 0, 0)
		sizer_19.Add(self.downloadFileList, 1, wx.EXPAND, 0)
		sizer_19.Add((20, 5), 0, 0, 0)
		sizer_21.Add((0, 20), 0, 0, 0)
		sizer_21.Add(self.downloadFileAdd, 0, 0, 0)
		sizer_21.Add((12, 20), 0, 0, 0)
		sizer_21.Add(self.downloadFileRm, 0, 0, 0)
		sizer_21.Add((12, 20), 0, 0, 0)
		sizer_21.Add(self.downloadFileClean, 0, 0, 0)
		sizer_21.Add((41, 20), 1, 0, 0)
		sizer_21.Add(self.downloadFileEncrypt, 0, wx.ALIGN_BOTTOM | wx.ALL, 0)
		sizer_21.Add((20, 20), 0, 0, 0)
		# sizer_21.Add(self.downloadFileCompress, 0, wx.ALIGN_BOTTOM, 0)
		sizer_21.Add(self.downloadFileBackup, 0, wx.ALIGN_BOTTOM, 0)
		sizer_19.Add(sizer_21, 0, wx.EXPAND, 0)
		sizer_19.Add((20, 5), 0, 0, 0)
		sizer_22.Add(self.downloadProgress, 1, wx.EXPAND, 0)
		sizer_22.Add((12, 20), 0, 0, 0)
		sizer_22.Add(self.downloadFileStart, 0, 0, 0)
		sizer_22.Add(self.downloadFileMore, 0, 0, 0)
		sizer_22.Add((5, 20), 0, 0, 0)
		sizer_22.Add(self.downloadFileCombine, 0, 0, 0)
		sizer_19.Add(sizer_22, 0, wx.EXPAND, 0)
		sizer_18.Add(sizer_19, 1, wx.EXPAND, 0)
		sizer_15.Add(sizer_18, 1, wx.ALL | wx.EXPAND, 3)
		self.notebook_1_pane_3.SetSizer(sizer_15)
		sizer_23.Add((20, 20), 0, 0, 0)
		sizer_4.Add((20, 20), 0, 0, 0)
		sizer_4.Add(self.autoSaveLogChk, 0, wx.ALL, 4)
		grid_sizer_1.Add(sizer_4, 1, wx.EXPAND, 0)
		sizer_3.Add(self.label_7, 0, wx.ALL, 4)
		sizer_3.Add(self.autoSaveLogMaxItem, 0, 0, 0)
		sizer_3.Add((20, 20), 0, 0, 0)
		sizer_3.Add(self.label_8, 0, wx.ALL, 4)
		sizer_3.Add(self.autoSaveLogMaxSize, 0, 0, 0)
		sizer_3.Add((20, 20), 0, 0, 0)
		sizer_3.Add(self.openAutoSaveLogDir, 1, wx.EXPAND, 0)
		grid_sizer_1.Add(sizer_3, 1, wx.EXPAND, 0)
		grid_sizer_1.Add((20, 20), 0, 0, 0)
		grid_sizer_1.Add((20, 20), 0, 0, 0)
		sizer_5.Add((20, 20), 0, 0, 0)
		sizer_5.Add(self.codeEditorChk, 0, wx.ALL, 4)
		grid_sizer_1.Add(sizer_5, 1, wx.EXPAND, 0)
		sizer_6.Add(self.codeEditorPathText, 0, 0, 0)
		sizer_6.Add(self.srcEditorBrowseBtn, 0, 0, 0)
		sizer_6.Add((20, 20), 0, 0, 0)
		sizer_6.Add(self.label_13, 0, wx.ALL, 4)
		sizer_6.Add(self.codeEditorParam, 0, 0, 0)
		grid_sizer_1.Add(sizer_6, 0, wx.EXPAND, 0)
		grid_sizer_1.Add((20, 20), 0, 0, 0)
		grid_sizer_1.Add((20, 20), 0, 0, 0)
		sizer_7.Add((20, 20), 0, 0, 0)
		sizer_7.Add(self.comSettingChk, 0, wx.ALL, 4)
		grid_sizer_1.Add(sizer_7, 1, wx.EXPAND, 0)
		sizer_24.Add(self.label_14, 0, wx.ALL, 4)
		sizer_24.Add(self.comParity, 0, 0, 0)
		sizer_24.Add((20, 20), 0, 0, 0)
		sizer_24.Add(self.label_15, 0, wx.ALL, 4)
		sizer_24.Add(self.comDatabit, 0, 0, 0)
		sizer_24.Add((20, 20), 0, 0, 0)
		sizer_24.Add(self.label_16, 0, wx.ALL, 4)
		sizer_24.Add(self.comStopbits, 0, 0, 0)
		sizer_24.Add((20, 20), 0, 0, 0)
		sizer_24.Add(self.label_17, 0, wx.ALL, 4)
		sizer_24.Add(self.comFlowControl, 1, 0, 0)
		grid_sizer_1.Add(sizer_24, 1, wx.EXPAND, 0)
		sizer_26.Add((20, 20), 0, 0, 0)
		grid_sizer_1.Add(sizer_26, 1, wx.EXPAND, 0)
		sizer_27.Add((20, 20), 0, 0, 0)
		grid_sizer_1.Add(sizer_27, 1, wx.EXPAND, 0)
		sizer_33.Add((20, 20), 0, 0, 0)
		sizer_33.Add(self.mpycChk, 0, wx.ALL, 4)
		grid_sizer_1.Add(sizer_33, 1, wx.EXPAND, 0)
		sizer_34.Add(self.mpycPathText, 1, 0, 0)
		sizer_34.Add(self.mpycBrowser, 0, 0, 0)
		grid_sizer_1.Add(sizer_34, 1, wx.EXPAND, 0)
		grid_sizer_1.Add((20, 20), 0, 0, 0)
		grid_sizer_1.Add((20, 20), 0, 0, 0)
		sizer_35.Add((20, 20), 0, 0, 0)
		sizer_35.Add(self.manualSettingChk, 0, wx.ALL, 4)
		grid_sizer_1.Add(sizer_35, 1, wx.EXPAND, 0)
		sizer_36.Add(self.openConfigFile, 0, 0, 0)
		grid_sizer_1.Add(sizer_36, 1, wx.EXPAND, 0)
		grid_sizer_1.Add((20, 20), 0, 0, 0)
		grid_sizer_1.Add((20, 20), 0, 0, 0)
		sizer_37.Add((20, 20), 0, 0, 0)
		sizer_37.Add(self.fontCheck, 0, wx.ALL, 4)
		grid_sizer_1.Add(sizer_37, 1, wx.EXPAND, 0)
		sizer_38.Add(self.fontButton, 0, 0, 0)
		grid_sizer_1.Add(sizer_38, 1, wx.EXPAND, 0)
		sizer_25.Add(grid_sizer_1, 1, wx.EXPAND, 0)
		sizer_23.Add(sizer_25, 0, wx.EXPAND, 0)
		sizer_32.Add((20, 20), 1, 0, 0)
		sizer_32.Add(self.configConfirm, 0, wx.ALIGN_BOTTOM | wx.ALL, 8)
		sizer_32.Add(self.configReset, 0, wx.ALIGN_BOTTOM | wx.ALL, 8)
		sizer_32.Add(self.configCancel, 0, wx.ALIGN_BOTTOM | wx.ALL, 8)
		sizer_32.Add((11, 20), 0, 0, 0)
		sizer_23.Add(sizer_32, 1, wx.EXPAND, 0)
		sizer_31.Add((20, 3), 0, 0, 0)
		sizer_23.Add(sizer_31, 0, wx.EXPAND, 0)
		self.notebook_1_pane_4.SetSizer(sizer_23)
		self.notebook_1.AddPage(self.notebook_1_pane_1, _(u"交互"))
		self.notebook_1.AddPage(self.notebook_1_pane_2, _(u"文件"))
		self.notebook_1.AddPage(self.notebook_1_pane_3, _(u"下载"))
		self.notebook_1.AddPage(self.notebook_1_pane_4, _(u"设置"))
		box_sizer_1.Add(self.notebook_1, 1, wx.EXPAND, 0)
		self.SetSizer(box_sizer_1)
		self.Layout()
		self.Centre()
		# end wxGlade
		
	def set_style(self, n, fore, back, default):
		self.stc.StyleSetForeground(n, fore)
		self.stc.StyleSetBackground(n, back)
		if default:
			self.stc.StyleSetFontAttr(
				n,
				12,
				"Lucida Sans Typewriter",
				False,
				False,
				False,
				33,
			)
		else:
			self.stc.StyleSetFontAttr(
				n,
				self.conf.getint('font', 'size'),
				self.conf.get('font', 'fontFace'),
				self.conf.getboolean('font', 'bold'),
				self.conf.getboolean('font', 'italic'),
				self.conf.getboolean('font', 'underline'),
				self.conf.getint('font', 'encoding'),
			)
		
	def stcColorized(self, state, default, colour):
		if state:
			# Check for font parameters from the config file
			font_color = "#CFD7E6" if default else colour

			self.set_style(wx.stc.STC_STYLE_DEFAULT,
						   font_color, 
						   "#282C34",
						   default
			)
			self.set_style(wx.stc.STC_STYLE_CONTROLCHAR,
						   font_color,
						   "#282C34",
						   default
			)
			self.set_style(wx.stc.STC_STYLE_BRACELIGHT,
						   font_color,
						   "#282C34",
						   default
			)
			self.set_style(wx.stc.STC_STYLE_BRACEBAD,
						   font_color,
						   "#282C34", 
						   default
			)
			# White space
			self.set_style(wx.stc.STC_P_DEFAULT,
						   font_color, 
						   "#282C34",
						   default
			)
			# Comment
			self.set_style(wx.stc.STC_P_COMMENTLINE,
						   "#454C59", 
						   "#282C34", 
						   default
			)
			# Number
			self.set_style(wx.stc.STC_P_NUMBER, 
						   "#E5C07B", 
						   "#282C34", 
						   default
			)
			# String
			self.set_style(wx.stc.STC_P_STRING,
						   "#B5E890",
						   "#282C34",
						   default
			)
			# Single quoted string
			self.set_style(wx.stc.STC_P_CHARACTER,
						   "#B5E890", 
						   "#282C34", 
						   default
			)
			# Keyword
			self.set_style(wx.stc.STC_P_WORD,
						   "#C678DD",
						   "#282C34",
						   default
			)
			# Triple quotes
			self.set_style(wx.stc.STC_P_TRIPLE,
						   "#B5E890",
						   "#282C34", 
							default
			)
			# Triple double quotes
			self.set_style(wx.stc.STC_P_TRIPLEDOUBLE,
						   "#B5E890",
						   "#282C34",
						   default
			)
			# Class name definition
			self.set_style(wx.stc.STC_P_CLASSNAME,
						   "#C678DD",
						   "#282C34",
						   default
			)
			# Function or method name definition
			self.set_style(wx.stc.STC_P_DEFNAME, 
						   font_color,
						   "#282C34",
						   default
			)
			# Operators
			self.set_style(wx.stc.STC_P_OPERATOR,
						   font_color,
						   "#282C34",
						   default
			)
			# Identifiers
			self.set_style(wx.stc.STC_P_IDENTIFIER,
						   font_color,
						   "#282C34",
						default
			)
			# Comment-blocks
			self.set_style(wx.stc.STC_P_COMMENTBLOCK, 
						   font_color, 
						   "#282C34", 
						   default
			)
			# End of line where string is not closed
			self.set_style(wx.stc.STC_P_STRINGEOL,
						   font_color, 
						   "#282C34", 
						   default
			)
			# Caret color
			self.stc.SetCaretForeground(font_color)
			self.stc.SetCaretWidth(2)
			
			# Selection background
			self.stc.SetSelBackground(1, '#264f78')
			
			# Line highlight
			self.stc.SetCaretLineBackground('#454C59')
			self.stc.SetCaretLineVisible(True)
			
			# Horizon scrollbar
			self.stc.SetUseHorizontalScrollBar(False)  

		else:
			# Check for font parameters from the config file
			font_color = "#383a42" if default else colour

			self.set_style(wx.stc.STC_STYLE_DEFAULT,
						   font_color, 
						   "#fafafa", 
						   default
			)
			self.set_style(wx.stc.STC_STYLE_CONTROLCHAR,
						   font_color, 
						   "#fafafa", 
						   default
			)
			self.set_style(wx.stc.STC_STYLE_BRACELIGHT,
						   font_color, 
						   "#fafafa", 
						   default
			)
			self.set_style(wx.stc.STC_STYLE_BRACEBAD, 
						   font_color, 
						   "#fafafa", 
						   default
			)
			# White space
			self.set_style(wx.stc.STC_P_DEFAULT,
						   font_color,
						   "#fafafa",
						   default
			)
			# Comment
			self.set_style(wx.stc.STC_P_COMMENTLINE, 
						   "#d4d4d4", 
						   "#fafafa", 
						   default
			)
			# Number
			self.set_style(wx.stc.STC_P_NUMBER,
						   "#c18402",
						   "#fafafa",
						   default
			)
			# String
			self.set_style(wx.stc.STC_P_STRING,
						   "#50a14f",
						   "#fafafa",
						   default
			)
			# Single quoted string
			self.set_style(wx.stc.STC_P_CHARACTER,
						   "#50a14f",
						   "#fafafa",
						   default
			)	  
			# Keyword
			self.set_style(wx.stc.STC_P_WORD,
						   "#a626a4", 
						   "#fafafa",
						   default
			)
			# Triple quotes
			self.set_style(wx.stc.STC_P_TRIPLE,
						   "#50a14f",
						   "#fafafa", 
						   default
			)	  
			# Triple double quotes
			self.set_style(wx.stc.STC_P_TRIPLEDOUBLE,
						   "#50a14f", 
						   "#fafafa", 
						   default
			)
			# Class name definition
			self.set_style(wx.stc.STC_P_CLASSNAME, 
						   "#a626a4",
						   "#fafafa",
						   default
			)
			# Function or method name definition
			self.set_style(wx.stc.STC_P_DEFNAME,
						   "#0084bc", 
						   "#fafafa", 
						   default
			)
			# Operators
			self.set_style(wx.stc.STC_P_OPERATOR,
						   font_color, 
						   "#fafafa", 
						   default
			)
			# Identifiers
			self.set_style(wx.stc.STC_P_IDENTIFIER,
						   font_color, 
						   "#fafafa", 
						   default
			)
			# Comment-blocks
			self.set_style(wx.stc.STC_P_COMMENTBLOCK,
						   "#454C59",
						   "#fafafa", 
						   default
			)
			# End of line where string is not closed
			self.set_style(wx.stc.STC_P_STRINGEOL,
						   font_color,
						   "#fafafa",
						   default
			)

			# Caret color
			self.stc.SetCaretForeground(font_color)
			self.stc.SetCaretWidth(2)
			
			# Selection background
			self.stc.SetSelBackground(1, '#264f78')
			
			# Line highlight
			self.stc.SetCaretLineBackground('#CFD7E6')
			self.stc.SetCaretLineVisible(True)
			
			# Horizon scrollbar
			self.stc.SetUseHorizontalScrollBar(False)
		
	def statusBarTimerFresh(self, event):	#fresh statusbar timer
		global statusBarStr, statusBarStrStatic
		
		if statusBarStr!="":
			self.statusBar.SetStatusText(" " + statusBarStr, 1)
		else:
			if statusBarStrStatic == "":
				self.statusBar.SetStatusText(_(u" 当前状态: 就绪..."), 1)
			else:
				self.statusBar.SetStatusText(statusBarStrStatic, 1)

		now = datetime.datetime.now()
		self.statusBar.SetStatusText(" " + now.strftime("%Y-%m-%d %H:%M:%S"), 2)
		# for file explore listview column width update
		
		self.localFileList.SetColumnWidth(0, self.localFileList.GetSize()[0]-\
										self.localFileList.GetColumnWidth(1)-\
										self.localFileList.GetColumnWidth(2)-\
										self.localFileList.GetColumnWidth(3)-30)
		#print(self.downloadFileList.GetSize())
		self.downloadFileList.SetColumnWidth(2, self.downloadFileList.GetSize()[0]-\
										self.downloadFileList.GetColumnWidth(0)-\
										self.downloadFileList.GetColumnWidth(1)-\
										self.downloadFileList.GetColumnWidth(3)-30)
		
		# for localFilePathStr var fresh
		global localFilePathStr
		localFilePathStr = self.localFilePath.GetValue()

		
	def lineWidthTimerFix(self, event):
		self.stc.SetMarginWidth(0, (len(str(self.stc.GetLineCount()))*(12+self.stc.GetZoom())+16)*self.stcLineNumberdisplayMode)
		self.stc.SetMarginWidth(1, 16*self.stcLineNumberdisplayMode)
		
	curLogName = ""
	curLogNameUse = False
	def autoSaveLogHandler(self, event):
		if self.conf.getint("software", "autosavelogmaxsize")==0 or self.conf.getint("software", "autosavelogmaxsize")==0:
			return None
		
		#20201231-23.59.59-0001.log
		if ifExist(PROJECT_ABSOLUTE_PATH + "\\logs\\apps\\")==False:
			makeDir(PROJECT_ABSOLUTE_PATH + "\\logs\\apps\\")
		
		while True:
			logFileNameList = getFileList(PROJECT_ABSOLUTE_PATH + "\\logs\\apps\\")
			#if folder is empty
			if len(logFileNameList)==0:
				self.curLogName = self.getNewLogfileName()
				self.curLogNameUse = True
				self.saveLogToFile(PROJECT_ABSOLUTE_PATH + "\\logs\\apps\\" + self.curLogName)
				break
				
			#if current file is in using
			if self.curLogNameUse==True:
				#if file not exist yet
				if ifExist(self.curLogName)==False: 
					self.curLogName = self.getNewLogfileName()
					self.curLogNameUse = True
					self.saveLogToFile(PROJECT_ABSOLUTE_PATH + "\\logs\\apps\\" + self.curLogName)
				# if bigger than 100m
				if getFileSize(PROJECT_ABSOLUTE_PATH + "\\logs\\apps\\" + self.curLogName)>self.conf.getint("software", "autosavelogmaxsize")*1000000:
					self.rmOldestLogfile()
					self.curLogName = self.getNewLogfileName()
					self.curLogNameUse = True
					self.saveLogToFile(PROJECT_ABSOLUTE_PATH + "\\logs\\apps\\" + self.curLogName)
					break
				else:
					self.saveLogToFile(PROJECT_ABSOLUTE_PATH + "\\logs\\apps\\" + self.curLogName)
					break
			
			#if folder's file number > limit
			if len(logFileNameList)>self.conf.getint("software", "autosavelogmaxitem"):
				self.curLogName = ""
				self.curLogNameUse = False
				self.rmOldestLogfile()
			
			#if folder
			if len(logFileNameList)<=self.conf.getint("software", "autosavelogmaxitem"):
				if self.curLogNameUse==True:
					self.saveLogToFile(PROJECT_ABSOLUTE_PATH + "\\logs\\apps\\" + self.curLogName)
					break
				else:
					self.rmOldestLogfile()
					self.curLogName = self.getNewLogfileName()
					self.curLogNameUse = True
					self.saveLogToFile(PROJECT_ABSOLUTE_PATH + "\\logs\\apps\\" + self.curLogName)
					break
					
	def rmOldestLogfile(self):
		sortedFileList = sorted(getFileList2(PROJECT_ABSOLUTE_PATH+"\\logs\\apps\\"), key = lambda i: i['mtime'])
		try:
			rmFile(PROJECT_ABSOLUTE_PATH + "\\logs\\apps\\" + sortedFileList[0]["name"])
		except:
			pass
			
			
	def getNewLogfileName(self):
		return time.strftime("%Y%m%d-%H.%M.%S", time.localtime(PROJECT_START_TIMESTAMP))+".log"
		
		
		
	def saveLogToFile(self, path):
		writeFile(path, "\n"+self.logVar, "a+")
		self.logVar = ""
			
	modFileDict = {}
	def serRcvHandler(self, event):
		global ser, serProcessing, serProctype, serProceOnce, serProcTmpVar, serLastRecvData, serLastRecvTime, nowTotalFileSize, tmpCmdLine, protectFileStr, fw_versionFlag,deviceList
		if ser.port not in deviceList:
			self.comOpenBtn(event)
			pub.sendMessage('uiUpdate', arg1="serialStaChange", arg2=serialList)
			return None
		try:
			if serProctype in ("ls","lsmore"):
				time.sleep(.4)
			num = ser.inWaiting()
		except:
			self.comOpenBtn(event)
			pub.sendMessage('uiUpdate', arg1="serialStaChange", arg2=serialList)
			return None
		
		if num>0:
			try:
				data = ser.read(num)
			except:
				self.comOpenBtn(event)
				wx.MessageBox(_(u'串口打开失败'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				return None
			#debug print serial received data
			#print("recv", data)
			serLastRecvData = data
			serLastRecvTime = time.time()
			if serProctype in ('batchDownload','rmFile','cleanFile','addFolder'):
				return None
			if serProcessing:	#for serial possess operation, list file/FW download
				self.serProCache = self.serProCache+data.decode("utf-8", errors="ignore")
				if self.serProCache.endswith(">>> "):
					'''
					if serProctype=="getVersion":
						modFileList = []
						[modFileList.append(i[1:-1]) for i in re.findall(">>>file<<< (.*[)$])", self.serProCache, re.I)]
						# Inital print of files on module system
						# print(modFileList)
						# Determine if it is a dual file system
						for i in modFileList:
							#fw_versionFlag = False if i.split(",")[0] == "'apn_cfg.json'" else True
							if i.split(",")[0] == "'apn_cfg.json'":
								fw_versionFlag = False
								break
							else:
								fw_versionFlag = True
						serProcessing = True
						serProctype = "ls"
						serProceOnce = False
						serProcTmpVar = None
						self.serProCache = ""
						return None
					'''
					if serProctype == "ls":
						nowTotalFileSize = 0
						self.addTree(self.modFileTree, "", "", True, True)
						#recv b"import uos\r\n>>> for f in uos.ilistdir('/'):\r\n...	  print('>>>file<<<', f)\r\n...	 \r\n...	 \r\n... \r\n>>>file<<< ('test', 16384, 0, 0)\r\n>>>file<<< ('"
						#recv b"\xe6\x96\xb0\xe5\xbb\xba\xe6\x96\x87\xe6\x9c\xac\xe6\x96\x87\xe6\xa1\xa3.txt', 32768, 0, 0)\r\n>>>file<<< ('0.txt', 32768, 0, 0)\r\n>>>file<<< ('\xe6\x96\xb0\xe5\xbb\xba.txt', 32768, 0, 51)\r\n>>> "
						
						#print(self.serProCache)
						# import uos
						# >>> for f in uos.ilistdir('/'):
						# ...	  print('>>>file<<<', f)
						# ...
						# ...
						# ...
						# >>>file<<< ('test', 16384, 0, 0)
						# >>>file<<< ('新建文本文档.txt', 32768, 0, 0)
						# >>>file<<< ('0.txt', 32768, 0, 0)
						# >>>file<<< ('新建.txt', 32768, 0, 51)
						# >>>
						
						# print(re.findall(">>>file<<< \((.*?\d)\)", self.serProCache))
						#["'test', 16384, 0, 0", "'新建文本文档.txt', 32768, 0, 0", "'0.txt', 32768, 0, 0", "'新建.txt', 32768, 0, 51"]
						#print(self.serProCache)
						modFileList = []
						[modFileList.append(i[1:-1]) for i in re.findall(">>>file<<< (.*[)$])", self.serProCache, re.I)]
													
						if len(modFileList)>0:
							for f in modFileList:
								#if len(f.split(","))!=4: continue
								if int(f.split(",")[1])&0x4000:	#a dir
									itemID = self.findItemByLabel(self.modFileTree, 'Root', self.modFileTree.GetRootItem())
									#print(itemID)
									subitemID = self.addTree(self.modFileTree, f.split(",")[0].strip("'"), itemID, haveSub=True)
									subitemid2 = self.addTree(self.modFileTree, str(random.randint(100001,999999)), subitemID, haveSub=True)
									self.addTree(self.modFileTree, str(random.randint(100001,999999)), subitemid2, haveSub=True)
									#self.modFileDict[f.split(",")[0].strip("'")]={'type': "<DIR>", 'size':f.split(",")[3]}
								else:
									nowTotalFileSize += int(f.split(",")[3])
									itemID = self.findItemByLabel(self.modFileTree, 'Root', self.modFileTree.GetRootItem())
									self.addTree(self.modFileTree, f.split(",")[0].strip("'"), itemID, False)
									#print(f)	#'stest.py', 32768, 0, 956
									self.modFileDict[f.split(",")[0].strip("'")]={'type': "<FILE>", 'size':f.split(",")[3]}
							self.modFileTree.SetItemText(self.modFileTree.GetRootItem(), "Root (" + str(self.modFileTree.GetCount()-1) + ")")
						else:
							itemID = self.findItemByLabel(self.modFileTree, 'Root', self.modFileTree.GetRootItem())
							self.addTree(self.modFileTree, '当前模块文件为空,请拖动文件到文件夹中', itemID, haveSub=False)
							
							
						#TODO can not do as os.walk, so, click + sign to refresh sub item now
						
						self.modFileTree.Expand(self.modFileTree.GetRootItem())
						self.modFileTree.SelectItem(self.modFileTree.GetRootItem())
						time.sleep(0.1)
						serProcessing = False				
						serProctype = ""
						serProceOnce = False
						serProcTmpVar = None
						
					if serProctype=="lsmore":
						modFileList = []
						[modFileList.append(i[1:-1]) for i in re.findall(">>>file<<< (.*[)$])", self.serProCache, re.I)]
						#print(modFileList)
						if len(modFileList)>0:
							for f in modFileList:
								#if len(f.split(","))!=4: continue
								if int(f.split(",")[1])&0x4000:	#a dir
									subitemID = self.addTree(self.modFileTree, f.split(",")[0].strip("'"), self.itemTmpID, haveSub=True)
									self.addTree(self.modFileTree, str(random.randint(100001,999999)), subitemID, haveSub=True)
									#self.modFileDict[f.split(",")[0].strip("'")]={'type': "<DIR>", 'size':f.split(",")[3]}
								else:
									#nowTotalFileSize += int(f.split(",")[3])
									self.addTree(self.modFileTree, f.split(",")[0].strip("'"), self.itemTmpID, False)
									#print(f)	#'stest.py', 32768, 0, 956
									self.modFileDict[f.split(",")[0].strip("'")]={'type': "<FILE>", 'size':f.split(",")[3]}
							self.modFileTree.SetItemText(self.modFileTree.GetRootItem(), "Root (" + str(self.modFileTree.GetCount()-1) + ")")
						#TODO can not do as os.walk, so, click + sign to refresh sub item now
						serProcessing = False
						serProctype = ""
						serProceOnce = False
						serProcTmpVar = None
					#print(nowTotalFileSize)
					#elif serProctype == "":
						#pass
						
				# if serProctype == "protectFile":
					# print(data.decode("utf-8", errors="ignore"))
					
					# writeStr = (data.decode("utf-8", errors="ignore").split('>>>')[1])[17:-1]
					# with open(serProcTmpVar+protectFileStr,'w',encoding="utf-8") as f:
						# f.write(writeStr)
					# serProcessing = False
					# serProctype = ""
					# serProceOnce = False
					# serProcTmpVar = None
						
				if serProctype == "downloadFile":
					self.serProCache = ""
					return None
				else:
					serProcessing = False
				self.serProCache = ""
				return None
				
			
			#interative cmd tab
			#print(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3] + " " + data.decode("utf-8", errors='ignore'))
			tmpLogData = data.decode("utf-8", errors='ignore')
			if "\r\r\n" in tmpLogData:
				tmpLogData = tmpLogData.replace("\r\r\n", "\n")
			#if tmpLogData.endswith("\r\n"): tmpLogData=tmpLogData[:-2]
			#print(tmpLogData)
			
			
			if tmpLogData[0:len(self.serSendList[-1])] != self.serSendList[-1]:
				if tmpLogData.startswith("dir"):
					tmpCmdLine = tmpCmdLine.strip('\r\n')
					#print('-----' + tmpCmdLine + '----------')
					tmpLogData = tmpLogData.replace(tmpCmdLine, "", 1)
					if 'Traceback' in tmpLogData:
						wx.Bell()
						return
					#tmpList = tmpLogData.split("', '")
					
					tmp = tmpLogData.strip('\r\n')[2:-8]
					#print(tmp)
					tmpList = tmp.split("', '")
					# print(tmpList)
					if len(tmpList) == 1:
						tmpLogData = tmpList[0]
						self.stc.WriteText(tmpLogData)
					else:
						tabListRes = tabListSelect(tmpList,self.tmpSelectStr)
						# print('Returns a list of matching results：  '+str(tabListRes))
						if len(tabListRes) == 1:
							#if  self.stc.GetCurLine()[0][4:] == tabListRes[0]:
							resStr = tabListRes[0].replace(self.tmpSelectStr,'',1)
							self.stc.WriteText(resStr)
						elif len(tabListRes) == 0:
							return
						else:
							self.stc.DocumentEnd()
							self.stc.NewLine()
							self.stc.WriteText(getPrintInfo(tabListRes)+'\r\n>>> ' + self.historyInStr)
					return None
			
				elif tmpLogData.startswith("import example"):
					pass
			elif tmpLogData[0:len(self.serSendList[-1])]==self.serSendList[-1]:
				if tmpLogData[0:len(self.serSendList[-1])]==self.serSendList[-1]:
					tmpLogData = tmpLogData.replace(self.serSendList[-1], "", 1)
						
			tmpLogData = (self.toolBar.GetToolState(3001) and (datetime.datetime.now().strftime("[%Y-%m-%d %H:%M:%S.%f")[:-3] + "] ") or "") + tmpLogData
			self.logVar = self.logVar+tmpLogData[:-1]
			if self.logPrtPause:
				if self.logPrtPauseCache:
					self.logCache.append(tmpLogData)
			else:
				if len(self.logCache)!=0:
					self.stc.DocumentEnd()
					self.stc.NewLine()
					#TODO: big cache crush ram
					for x in self.logCache:
						self.stc.WriteText(x)
						self.stc.NewLine()
					self.logCache = []
				self.stc.DocumentEnd()
				self.stc.NewLine()
				self.stc.WriteText(tmpLogData)
							
							
	def addTree(self, ListObj, str, parentItem, haveSub=False, Root=False):
		if Root:
			ListObj.DeleteAllItems()
			#treeIconList.RemoveAll()	#no need to remove, maybe?
			root = ListObj.AddRoot("Root")
			ListObj.SetItemImage(root, self.fldridx, wx.TreeItemIcon_Normal)
			ListObj.SetItemImage(root, self.fldropenidx, wx.TreeItemIcon_Expanded)
			return root
		else:
			if haveSub:
				newItem = ListObj.AppendItem(parentItem, str)
				ListObj.SetItemImage(newItem, self.fldridx, wx.TreeItemIcon_Normal)
				ListObj.SetItemImage(newItem, self.fldropenidx, wx.TreeItemIcon_Expanded)
				return newItem
			else:
				newItem = ListObj.AppendItem(parentItem, str)
				if str[-3:].lower()==".py":
					ListObj.SetItemImage(newItem, self.filepy, wx.TreeItemIcon_Normal)
				else:
					ListObj.SetItemImage(newItem, self.fileidx, wx.TreeItemIcon_Normal)
				return newItem
				
	# Get the itemID based on the label passed in		
	def findItemByLabel(self, tree, search_text, root_item):	#without root item
		if tree.GetItemText(tree.GetRootItem()).lower()==search_text.lower():
			return tree.GetRootItem()
		
		item, cookie = tree.GetFirstChild(root_item)
		while item.IsOk():
			text = tree.GetItemText(item)
			if text.lower() == search_text.lower():
				return item
			if tree.ItemHasChildren(item):
				match = self.findItemByLabel(tree, search_text, item)
				if match.IsOk():
					return match
			item, cookie = tree.GetNextChild(root_item, cookie)
		return tree.GetRootItem()

	def getItemPathList(self, id, tree, reverse=False):
		pieces = []
		while tree.GetItemParent(id):
			piece = tree.GetItemText(id)
			pieces.insert(0, piece)
			id = tree.GetItemParent(id)
		pieces.insert(0, tree.GetItemText(id))
		
		if reverse:
			pieces.reverse()
			return pieces
		else:
			return pieces
		
	#Gets the entire text of the tree control
	def getItemList(self, treeCtrl):
		result = []
		treeRoot = treeCtrl.GetRootItem()
		rootText = treeCtrl.GetItemText(treeRoot)
		result.append(rootText)
		def recursivelyGetTreeItem(tree,leval):
			#Recursively traverses all the children of TreeCtrl
			(item,cookie) = treeCtrl.GetFirstChild(tree)
			while item.IsOk():
				result.append(treeCtrl.GetItemText(item))
				if treeCtrl.GetChildrenCount(item)>0:
					leval+=1
					recursivelyGetTreeItem(item,leval)
					leval-=1
				(item,cookie) = treeCtrl.GetNextChild(item,cookie)

		leval = 0   # The subtree level of recursion
		recursivelyGetTreeItem(treeRoot,leval)
		return result
		
	def statusBarMessages(self,arg1):
		global statusBarStr, flag_download_finished, flag_download_failed, flag_download_start, disconnectedStatus, flag_script_download_failed
		if arg1=="serListUpd":
			# usb_port = []
			# download_port = []
			# for p in list(serPort.comports()):
				# if self.pCfg["firmware"]["vid_pid_work"] and self.pCfg["firmware"]["USB_Serial_Device"] in p.hwid:
					# usb_port.append(p.device)			
				# elif self.pCfg["firmware"]["vid_pid_dwload"] and self.pCfg["firmware"]["Quectel_Download_Port"] in p.hwid:				
					# download_port.append(p.device)
					
			usb_port = self.comPortNumber(self.pCfg["firmware"]["vid_pid_work"], self.pCfg["firmware"]["Quectel_USB_AT_Port"])	
			download_port = self.comPortNumber(self.pCfg["firmware"]["vid_pid_dwload"])
			
			# ver_python = self.atGetPythonVersion()
			# sim_status = self.getSimStatus()
			# call_status = self.getDataCallInfo()
			# net_status = self.getNetState()
			ver_python = 1
			sim_status = 0
			call_status = 0
			net_status = 0
			if download_port == None and usb_port == None and flag_download_finished != True and flag_download_start == True:
				statusBarStr = _(u"USB串行设备在下载固件时失去连接!")
				# while flag_download_failed != True: 
					# time.sleep(1)
					# pass				
				flag_download_start = False
				flag_download_failed = False
				statusBarStr = _(u"当前状态：检测模块...")			   
			elif usb_port == None and disconnectedStatus == True:
				if flag_script_download_failed == True:
					statusBarStr = _(u"USB串行设备在下载脚本时失去连接!")			
				else:
					statusBarStr = _(u"USB串行设备失去连接!")			
				time.sleep(2)
				disconnectedStatus = False
				flag_script_download_failed = False
				statusBarStr = _(u"当前状态：检测模块...")
			elif ver_python != 1 and ver_python != None:
				statusBarStr = _(u"当前固件版本非Python版本!")
			elif sim_status == None and call_status == None and net_status == None:
				if flag_download_start == True:
					statusBarStr = _(u"下载固件中请勿退出软件")
				else:
					statusBarStr = _(u"当前状态：检测模块...")
			else:
				# time.sleep(1)
				# statusBarStr = sim_status
				# time.sleep(1)
				# statusBarStr = call_status
				# time.sleep(1)
				# statusBarStr = net_status
				# time.sleep(1)
				statusBarStr = ""
		
	def updateDisplay(self, arg1, arg2):
		#refresh serial list in main frame section
		# perc = int(arg1)
		global ser, serProcessing, serProctype, serProceOnce, serProcTmpVar, serLastRecvTime, serLastRecvData
		if arg1=="serListUpd":
			tmpSerialList = []
			# TODO The probability of USB to TTL is mistakenly identified as CDC port
			pdevice = []
			for p in list(serPort.comports()):
				if self.pCfg["firmware"]["vid_pid_work"] and self.pCfg["firmware"]["USB_Serial_Device"] in p.hwid:
					pdevice.append(p.device)			
			if len(pdevice) > 2:
				wx.MessageBox(_(u'请勿重复插入模块'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)				
				tmpSerialList.clear()				
				self.comSelector.SetItems(tmpSerialList)
				# print(self.comSelector.GetSelection()) 
				if self.comSelector.GetSelection()!=0:
					self.comSelector.SetSelection(0)
				self.comSelector.SetToolTip(self.comSelector.GetString(self.comSelector.GetSelection()))
				return
			for port, desc, hwid in sorted(serialList, reverse=True):
				tmpSerialList.append(" " + port + " - " + desc.split(" (")[0])
			#print("seriallist", tmpSerialList)
			self.comSelector.SetItems(tmpSerialList)
			#print(self.comSelector.GetSelection())
			if self.comSelector.GetSelection()!=0:
				self.comSelector.SetSelection(0)
			self.comSelector.SetToolTip(self.comSelector.GetString(self.comSelector.GetSelection()))
		
		elif arg1=="serialStaChange":
			# todo after open serial, refresh file list in modules.
			# todo need to change icon on button (file tab)
			# todo i18n(internationalization) support(gettext)
			if ser.isOpen():
				self.comOpen.SetLabel(_(u"关闭串口"))
				self.comOpen.SetBitmap(wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\closeCOM.ico", wx.BITMAP_TYPE_ICO))
				self.toolBar.SetToolNormalBitmap(3011,wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\play-disable.ico", wx.BITMAP_TYPE_ICO))
				self.toolBar.SetToolNormalBitmap(3012,wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\pause.ico", wx.BITMAP_TYPE_ICO))
				self.comSelector.Enable(False)
				self.comBaud.Enable(False)
				self.label_3.Enable(False)
				self.label_4.Enable(False)
				self.label_14.Enable(False)
				self.label_15.Enable(False)
				self.label_16.Enable(False)
				self.label_17.Enable(False)
				self.comParity.Enable(False)
				self.comDatabit.Enable(False)
				self.comStopbits.Enable(False)
				self.comFlowControl.Enable(False)
				self.comSettingChk.Enable(False)
				self.comSettingChk.SetValue(False)
				self.comSettingMore.Enable(False)
				#fresh mod file list
				# If you want to switch to a compatible version, you simply unload this piece of code
				# serProcessing = True	#continue "ls" operation 
				# serProceOnce = False
				# serProcTmpVar = None
				# serProctype = "getVersion"
				# print(serLastRecvTime)
				serLastRecvData = b""
				serLastRecvTime = 0
				if serLastRecvTime == 0:
					serProcessing = True # The default is a dual file system
					serProctype = "ls"
					serProceOnce = False
					serProcTmpVar = None
			else:
				self.comOpen.SetBitmap(wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\openCOM.ico", wx.BITMAP_TYPE_ICO))
				self.toolBar.SetToolNormalBitmap(3011,wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\play-disable.ico", wx.BITMAP_TYPE_ICO))
				self.toolBar.SetToolNormalBitmap(3012,wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\pause-disable.ico", wx.BITMAP_TYPE_ICO))
				self.comOpen.SetLabel(_(u"打开串口"))
				self.comSelector.Enable(True)
				self.comBaud.Enable(True)
				self.label_3.Enable(True)
				self.label_4.Enable(True)
				self.comSettingChk.Enable(True)
				self.comSettingMore.Enable(True)
				#reset serial operation status
				serProcessing = False	# have some opeation need to process?
				serProceOnce = False	# has proceed(current loop. maybe need multi loop for walk dir)
				serProctype = ""		# ls: list file operation; downloadFile:downloadFile to mod
				serProcTmpVar = None	# store some var, like current file path
				
				

				
	def CMDHandler(self,event):
		self.cmdcnt = self.conf.get("QuickCMD", "cmdcnt")
		if int(self.cmdcnt) > 16:
			wx.MessageBox(_(u'内置命令的最大限制是16!'),
						  _(u'提示'),
						  wx.YES_DEFAULT | wx.ICON_INFORMATION
			)
			return None

		self.Bind(wx.EVT_MENU,
				  self.toolPopupMenu,
				  id = 6001,
				  id2=6000+int(self.cmdcnt)
		)		

		menu = wx.Menu()
		for i in range(int(self.cmdcnt)):
			cmd_str = "cmd" + str(i+1)
			cmd = self.conf.get("QuickCMD", cmd_str).split('|')[0]
			# length of the command name
			if len(cmd) > 15:
				wx.MessageBox(_(u'命令名称过长！'),
							  _(u'提示'),
							  wx.YES_DEFAULT | wx.ICON_INFORMATION
				)

				return None

			item = wx.MenuItem(menu, 6001+int(i), cmd)
			item.Enable(enable = True)
			menu.Append(item)
		self.PopupMenu(menu)
		menu.Destroy()

		
	def toolPopupMenu(self, event):
		global ser, serProctype, serProcessing, serProceOnce, serProcTmpVar
		if ser.isOpen()==False:
			wx.MessageBox(_(u'请先打开串口'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			return None
		self.notebook_1.SetSelection(0)
		serProctype="QuickCMDInfo"
		serProcessing = True
		serProceOnce = False
		for i in range(int(self.cmdcnt)):
			if event.GetId()==6001+ int(i):
				cmdStr = "cmd" + str(i+1)
				serProcTmpVar = self.conf.get("QuickCMD", cmdStr).split('|')[1]
				return
		
	def OnSTCContextMenu(self, event):  # wxGlade: qpyTools.<event_handler>
		#print(self.stc.GetCurrentLine()+1,self.stc.GetLineCount())	#last line
		self.Bind(wx.EVT_MENU, self.OnSTCPopupMenu,id = 4001,id2 = 4007)
		menu = wx.Menu()
		item = wx.MenuItem(menu, 4001, _(u"撤销"))
		item.Enable(enable = self.stc.CanUndo()) 
		menu.Append(item)
		item = wx.MenuItem(menu, 4002, _(u"恢复"))
		item.Enable(enable = self.stc.CanRedo()) 
		menu.Append(item)
		menu.AppendSeparator()
		item = wx.MenuItem(menu, 4003, _(u"剪切"))
		item.Enable(enable = self.stc.CanCut() and self.stc.GetCurrentLine()+1==self.stc.GetLineCount())
		menu.Append(item)
		item = wx.MenuItem(menu, 4004, _(u"复制"))
		item.Enable(enable = self.stc.CanCopy())
		menu.Append(item)
		item = wx.MenuItem(menu, 4005, _(u"粘贴"))
		item.Enable(enable = self.stc.CanPaste() and self.stc.GetCurrentLine()+1==self.stc.GetLineCount())
		menu.Append(item)
		#item = wx.MenuItem(menu, 4006, "删除")
		#item.Enable(enable = not self.stc.GetSelectionEmpty() and self.stc.GetCurrentLine()+1==self.stc.GetLineCount())
		#menu.Append(item)
		menu.AppendSeparator()
		item = wx.MenuItem(menu, 4007, _(u"全部选择"))
		item.Enable(enable = True)
		menu.Append(item)
		self.PopupMenu(menu)
		menu.Destroy()
				
	def OnSTCPopupMenu(self, event):
		#print(event.GetId())
		if event.GetId()==4001:
			self.stc.Undo()
		elif event.GetId()==4002:
			self.stc.Redo()
		elif event.GetId()==4003:
			self.stc.Cut()
		elif event.GetId()==4004:
			self.stc.Copy()
		elif event.GetId()==4005:
			self.stc.Paste()
			self.forbidChar(event)
		#elif event.GetId()==4006:
		#	self.stc.Clear()
		elif event.GetId()==4007:
			self.stc.SelectAll()
	tmpTabVarList = []
	tmpTabVar = 1

	## SLOBODAN

	# def contains_non_latin(self, strs):
	#	 for _char in strs:
	#		 if '\u4e00' <= _char <= '\u9fa5':
	#			 return True
	#	 return False
	
	def has_only_latin_letters(self, strs):
		char_set = string.printable
		return all((True if x in char_set else False for x in strs))

	def forbidChar(self, event):
		# self.CONTENT = self.stc.GetValue()
		self.CONTENT = self.stc.GetCurLine()[0]
		# todo Only the characters entered in the REPL are restricted, not the characters output
		if not self.has_only_latin_letters(self.CONTENT): 
			data = re.sub("([^\x00-\x7F])+","", self.CONTENT)
			#self.stc.SetValue(data)
			self.stc.Replace(self.stc.GetCurrentPos()-self.stc.GetCurLine()[1],self.stc.GetCurrentPos(),data)
			self.stc.GotoPos(self.stc.GetCurrentPos() + len(data))

	def DoKeyPress(self, event):  # wxGlade: qpyTools.<event_handler>
		#keycode not in allow list, goto doc's end
		# print(event.GetKeyCode())
		#check if serial port opened
		global ser, serLastRecvData, serProcessing, serProctype, serProceOnce, serProcTmpVar, tmpCmdLine
		tmpSTContent = self.stc.GetValue()
		if ser.isOpen() == False:
			wx.MessageBox(_(u'请先打开串口'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			self.stc.SetValue(tmpSTContent)
			self.stc.DocumentEnd()
			tmpSTContent = ""
			return None

		if self.logPrtPause:
			return None

		if self.toolBar.GetToolState(3001):
			wx.MessageBox(_(u'【显示打印时间】模式，不可输入'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			return None

		#caret not at last line, move caret to document's end
		if self.stc.GetCurrentLine()+1 != self.stc.GetLineCount():
			if event.GetKeyCode() in keycodeOtherLineWhiteList.values():
				event.Skip()
			else:
				self.stc.DocumentEnd()
			
		#get current carrent position
		#self.stc.GetCurrentLine() + 1
		#self.stc.GetColumn(self.stc.GetCurrentPos()))
		strRaw, colCnt= self.stc.GetCurLine()
		#caret inside >>>_
		if colCnt<4 and (strRaw[:4]==">>> " or strRaw[:4]=="... "):
			if event.GetKeyCode() not in keycodeLastlineCtrlWordWhiteList.values():
				return None
		#caret at the edge of >>>_|
		# or not serLastRecvData.decode("utf-8", errors="ignore").endswith(">>> ")
		elif colCnt==4 and (strRaw[:4]==">>> " or strRaw[:4]=="... "):
			#forbid backspace
			if event.GetKeyCode()==8:
				return None
			#forbid selection replace feature
			if not self.stc.GetSelectionEmpty():
				#if selection include >>>_ or ..._
				if (self.stc.GetSelectedText() in ">>> ") or (self.stc.GetSelectedText() in "... "):
					if event.GetKeyCode()==13 or event.GetKeyCode()==370:
						self.stc.DocumentEnd()
					if event.GetKeyCode() not in keycodeLastlineCtrlWordWhiteList.values():
						return None
					
		#caret at last line, home button skip header such as >>>_ or ..._
		if self.stc.GetCurrentLine()+1==self.stc.GetLineCount():
			if event.GetKeyCode()==313:
				if not event.ShiftDown():	#home button without shift down
					self.stc.GotoPos(self.stc.GetCurrentPos()-colCnt)
					self.stc.CharRight()
					self.stc.CharRight()
					self.stc.CharRight()
					self.stc.CharRight()
					return None
				else:
					self.stc.AddSelection(self.stc.GetCurrentPos(), self.stc.GetCurrentPos()-colCnt+4)
					return None
		
		#enable copy function on full text
		if (event.GetKeyCode()==67 or event.GetKeyCode()==322) and event.ControlDown():
			self.stc.Copy()
			return None
		
		
		#caret at last 2 line, and press down button, jump to document end
		if self.stc.GetCurrentLine()+2==self.stc.GetLineCount() and event.GetKeyCode() in [317, 379]:
			self.stc.DocumentEnd()
		if self.stc.GetCurrentLine()+self.stc.LinesOnScreen()>=self.stc.GetLineCount() and event.GetKeyCode() in [367, 381]:
			self.stc.DocumentEnd()
		
		if event.GetKeyCode()==13 or event.GetKeyCode()==370:
			self.tmpTabVar = 1
			self.tmpTabVarList = []
			tmpCmdLine = self.stc.GetCurLine()[0]
			if tmpCmdLine[0:4]=='>>> ':
				tmpCmdLine = tmpCmdLine[4:]
			if tmpCmdLine[0:4]=="... ":
				tmpCmdLine = tmpCmdLine[4:]
			tmpCmdLine = tmpCmdLine.strip() + "\r\n"
			#print(type(tmpCmdLine))
			#tmpCmdLine = tmpCmdLine.decode()
			tmpCmdLineByte = tmpCmdLine.encode('utf-8', errors="ignore")
			#print(tmpCmdLineByte, len(tmpCmdLineByte))
			ser.write(tmpCmdLineByte)
			self.logVar = self.logVar+tmpCmdLine[:-1]
			if len(self.serSendList) > 500:
				del self.serSendList[0]
			self.serSendList.append(tmpCmdLine)
			return None
		# up button, show history command on last line
		if event.GetKeyCode() in (315,366):
			#print(self.serSendList)
			if self.stc.GetCurrentLine()+1==self.stc.GetLineCount():
				while True:
					if len(self.serSendList) == 0:
						break
					elif self.tmpTabVar>len(self.serSendList):
						break
					else:
						serSendUpstr = self.serSendList[-self.tmpTabVar:]
						if serSendUpstr[0] == '\r\n':
							self.tmpTabVar += 1 
						else:
							self.tmpTabVar += 1
							#self.stc.AddSelection(self.stc.GetCurrentPos(), self.stc.GetCurrentPos()-colCnt+4)
							#self.stc.ReplaceSelection(str(serSendUpstr[0]))
							serSendUpstr = serSendUpstr[0].strip('\r\n')
							#print(serSendUpstr)
							self.stc.Replace(self.stc.GetCurrentPos()-colCnt+4,self.stc.GetCurrentPos(),serSendUpstr)
							#strRaw, colCnt= self.stc.GetCurLine()
							#print(self.stc.GetCurrentLine())
							#lineEndPos = self.stc.GetLineEndPosition(self.stc.GetCurrentLine())
							#print(self.stc.GetCurrentPos())
							#print(lineEndPos)
							#self.stc.SetCurrentPos(lineEndPos)
							#self.stc.GotoPos(lineEndPos)
							
							break
				#tmpTabVarList Inverted SendList with values (default -2)
				#tmpTabVar The current value of up (subscript in the sendList) is returned to 0
				
				self.tmpTabVarList.append(self.tmpTabVar)
				self.stc.DocumentEnd()
				self.tmpTabVarList = sorted(list(set(self.tmpTabVarList)))
				#print(self.tmpTabVarList)
				return None
			else:
				return
		# down button back to last up button		
		if event.GetKeyCode() in (317,367):
			if self.stc.GetCurrentLine()+1==self.stc.GetLineCount():
				if self.tmpTabVar == 1:
					self.stc.DocumentEnd()
				else:
					#print(self.tmpTabVarList)
					#print(self.tmpTabVar)
					index = self.tmpTabVarList.index(self.tmpTabVar)
					#print(index)
					#print(len(self.tmpTabVarList))
					if index == 0:
						self.stc.Replace(self.stc.GetCurrentPos()-colCnt+4,self.stc.GetCurrentPos(),'')
					else:
						last_tmpTabVar = self.tmpTabVarList[index-1]
						#print(last_tmpTabVar)
						#print(self.serSendList[-(last_tmpTabVar-1)])
						serSendDownstr = self.serSendList[-(last_tmpTabVar-1)].strip('\r\n')
						#print(serSendDownstr)
						self.stc.Replace(self.stc.GetCurrentPos()-colCnt+4,self.stc.GetCurrentPos(),serSendDownstr)
						self.tmpTabVar = last_tmpTabVar
				self.stc.DocumentEnd()
				return None
			else:
				return
		# todo AutoCompleteCode with tab button
		if self.stc.GetCurrentLine()+1==self.stc.GetLineCount():
			if event.GetKeyCode()==9:
				if self.stc.GetCurLine()[0][0:4] == "... ":
					return None
				tmpCmdLine = self.stc.GetCurLine()[0][4:]
				self.historyInStr = tmpCmdLine
				self.tmpSelectStr = setTabStr(tmpCmdLine.strip())
				tmpCmdLine = getTabStr(tmpCmdLine.strip())
				tmpCmdLine = 'dir(' + tmpCmdLine + ')'
				#print(tmpCmdLine)
					
				tmpCmdLine = tmpCmdLine.strip() + "\r\n"
				tmpCmdLineByte = tmpCmdLine.encode('utf-8', errors="ignore")
				ser.write(tmpCmdLineByte)
				return None
		# else:
		#	 self.stc.DocumentEnd()
		event.Skip()
			
	def comOpenBtn(self, event):  # wxGlade: qpyTools.<event_handler>
		global disconnectedStatus
		global ser, serProcessing, serProctype, serProceOnce, serProcTmpVar
		if ser.isOpen():
			try:
				self.serRcvTimer.Stop()
				ser.close()
				pub.sendMessage('uiUpdate', arg1="serialStaChange", arg2=serialList)
				disconnectedStatus = True
			except:
				pass
		else:
			comStr = self.comSelector.GetString(self.comSelector.GetCurrentSelection()).split(' ')
			comFC = self.comFlowControl.GetString(self.comFlowControl.GetCurrentSelection())
			if len(comStr)<=2:
				wx.MessageBox(_(u'未检测到串口'), _(u'错误'), wx.YES_DEFAULT | wx.ICON_ERROR)
			else:
				ser.port = comStr[1]
				ser.baudrate = int(self.comBaud.GetString(self.comBaud.GetCurrentSelection()))
				ser.bytesize = int(self.comDatabit.GetString(self.comDatabit.GetCurrentSelection()))
				ser.parity = self.comParity.GetString(self.comParity.GetCurrentSelection())[0:1]
				ser.stopbits = int(self.comStopbits.GetString(self.comStopbits.GetCurrentSelection()))
				
				if "XON" in comFC:
					ser.xonoff = True
				if "RTS" in comFC:
					ser.rtscts = True
				if "DSR" in comFC:
					ser.dsrdtr = True
				
				try:
					#open serial port
					ser.open()
					#start timer to receive data from serial
					self.serRcvTimer.Start(100)
					pub.sendMessage('uiUpdate', arg1="serialStaChange", arg2=serialList)
					#save settings to config.ini
					self.saveSettings(0)
					#fresh mod file list
					disconnectedStatus = False
				except Exception as e:
					wx.MessageBox(_(u'串口打开失败') + '\n' + str(e), _(u'错误'), wx.YES_DEFAULT | wx.ICON_ERROR)
					return None	
			
	def comSettingBtn(self, event):  # wxGlade: qpyTools.<event_handler>
		self.notebook_1.SetSelection(3)
		self.comSettingChk.SetValue(True)
		self.changeSerialSettingChk(0)
		
	def logPauseBtn(self, event):  # wxGlade: qpyTools.<event_handler>
		print("Event handler 'logPauseBtn' not implemented!")
		event.Skip()
	def logStopBtn(self, event):  # wxGlade: qpyTools.<event_handler>
		print("Event handler 'logStopBtn' not implemented!")
		event.Skip()
	def autoSaveLogChkToggle(self, event):  # wxGlade: qpyTools.<event_handler>
		curChkStatus = self.autoSaveLogChk.GetValue()
		self.label_7.Enable(curChkStatus)
		self.label_8.Enable(curChkStatus)
		self.autoSaveLogMaxItem.Enable(curChkStatus)
		self.autoSaveLogMaxSize.Enable(curChkStatus)
		
	def codeEditorToggle(self, event):  # wxGlade: qpyTools.<event_handler>
		curChkStatus = self.codeEditorChk.GetValue()
		self.codeEditorPathText.Enable(curChkStatus)
		self.srcEditorBrowseBtn.Enable(curChkStatus)
		self.label_13.Enable(curChkStatus)
		self.codeEditorParam.Enable(curChkStatus)

	def toolBarHandler(self, event):  # wxGlade: qpyTools.<event_handler>
		global ser,ontopFlag
		if event.GetId()==3011:		#start
			self.notebook_1.SetSelection(0)
			self.logPrtPause = False
			self.logPrtPauseCache = False
			if ser.isOpen():
				self.toolBar.SetToolNormalBitmap(3011,wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\play-disable.ico", wx.BITMAP_TYPE_ICO))
				self.toolBar.SetToolNormalBitmap(3012,wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\pause.ico", wx.BITMAP_TYPE_ICO))
		elif event.GetId()==3012:	#pause
			self.notebook_1.SetSelection(0)
			self.logPrtPause = True
			self.logPrtPauseCache = True
			if ser.isOpen():
				self.toolBar.SetToolNormalBitmap(3011,wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\play.ico", wx.BITMAP_TYPE_ICO))
				self.toolBar.SetToolNormalBitmap(3012,wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\pause-disable.ico", wx.BITMAP_TYPE_ICO))
		elif event.GetId()==3013:	#stop
			self.notebook_1.SetSelection(0)
			if self.logPrtPause == False:
				self.toolBar.SetToolNormalBitmap(3011,wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\play.ico", wx.BITMAP_TYPE_ICO))
				self.toolBar.SetToolNormalBitmap(3012,wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\pause-disable.ico", wx.BITMAP_TYPE_ICO))
			self.logPrtPause = True
			self.logPrtPauseCache = False
			
		elif event.GetId()==3014:	#clean
			self.notebook_1.SetSelection(0)
			self.stc.ClearAll()
			self.stc.SetValue(">>> ")
			self.stc.DocumentEnd()
		elif event.GetId()==3001:	#time stamp
			pass
		elif event.GetId()==3002:	#line number
			if self.toolBar.GetToolState(3002)==False:
				self.stcLineNumberdisplayMode = 0
			else:
				self.stcLineNumberdisplayMode = 1
		elif event.GetId()==3003:	#colorized
				self.stcColorized(self.toolBar.GetToolState(3003),
							  self.conf.getboolean('font', 'default'),
							  self.stc_colour
			)
		elif event.GetId()==3021:	#save toolbar
			self.saveLogFunc()
		elif event.GetId()==3022:	#search
			self.notebook_1.SetSelection(0)
			self.searchFullTextContent = self.stc.GetValue()
			self.searchData = wx.FindReplaceData()
			self.searchData.SetFlags(wx.FR_DOWN)
			dlg = wx.FindReplaceDialog(self.stc, self.searchData, _(u'搜索'))
			dlg.Bind(wx.EVT_FIND, self.OnFind)
			dlg.Bind(wx.EVT_FIND_NEXT, self.OnFind)
			dlg.Bind(wx.EVT_FIND_CLOSE, self.OnQuit)
			dlg.Show()
		elif event.GetId()==3031:	#settings page
			self.notebook_1.SetSelection(3)
		elif event.GetId()==3033:
			# Get modified time of config.ini before dialog
			cfg_path = PROJECT_ABSOLUTE_PATH + "\\config.ini"
			curr_mtime = os.path.getmtime(cfg_path)
			dlg = CMDDialog(None)
			result = dlg.ShowModal()
			new_mtime = os.path.getmtime(cfg_path)
			# If file changed successfully inform the user to restart the app			  
			if new_mtime != curr_mtime:		  
				wx.MessageBox(_(u'You need to restart ' 
								'the application in order ' 
								'for changes to take effect!'),
					_(u'提示'),
					wx.YES_DEFAULT | wx.ICON_INFORMATION
				)
		elif event.GetId()==3034:	#set window ontop
			if ontopFlag:
				self.toolBar.SetToolNormalBitmap(3034,wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\ontop.ico", wx.BITMAP_TYPE_ICO))
				ontopFlag = False
			else:
				self.toolBar.SetToolNormalBitmap(3034,wx.Bitmap(PROJECT_ABSOLUTE_PATH + "\\images\\ontop-disable.ico", wx.BITMAP_TYPE_ICO))
				ontopFlag = True
			self.ToggleWindowStyle(wx.STAY_ON_TOP)
			
	def OnFind(self, event):
		editor = self.stc
		end = editor.GetLastPosition()
		textstring = editor.GetRange(0, end).lower()
		findstring = self.searchData.GetFindString().lower()
		backward = not (self.searchData.GetFlags() & wx.FR_DOWN)
		if backward:
			start = editor.GetSelection()[0]
			loc = textstring.rfind(findstring, 0, start)
		else:
			start = editor.GetSelection()[1]
			loc = textstring.find(findstring, start)
		if loc == -1 and start != 0:
			# string not found, start at beginning
			if backward:
				start = end
				loc = textstring.rfind(findstring, 0, start)
			else:
				start = 0
				loc = textstring.find(findstring, start)
		if loc == -1:
			dlg = wx.MessageDialog(self, 
								   _(u'未查询到匹配值!'),
								   _(u'提示'),
									wx.OK | wx.ICON_INFORMATION)
			dlg.ShowModal()
			dlg.Destroy()

		editor.ShowPosition(loc)
		editor.SetSelection(loc, loc + len(findstring))


	
	def OnQuit(self, event):
		self.stc.DocumentEnd()
			
	def comSelectorChange(self, event):  # wxGlade: qpyTools.<event_handler>
		self.comSelector.SetToolTip(self.comSelector.GetString(self.comSelector.GetSelection()))  
		
	def manualEditConfigure(self, event):  # wxGlade: qpyTools.<event_handler>
		self.openConfigFile.Enable(self.manualSettingChk.GetValue())
		
	def fontCheckConfigure(self, event):  # wxGlade: qpyTools.<event_handler>
		self.fontButton.Enable(self.fontCheck.GetValue())
		
	def openConfigureFile(self, event):  # wxGlade: qpyTools.<event_handler>
		p = subprocess.Popen("explorer.exe " + PROJECT_ABSOLUTE_PATH + "\\config.ini",shell = True)
		wx.Exit()
		self.Close(True)
	def changeSerialSettingChk(self, event):  # wxGlade: qpyTools.<event_handler>
		curChkStatus = self.comSettingChk.GetValue()
		global ser, serProcessing, serProctype, serProceOnce, serProcTmpVar
		if ser.isOpen()==False:
			self.label_14.Enable(curChkStatus)
			self.label_15.Enable(curChkStatus)
			self.label_16.Enable(curChkStatus)
			self.label_17.Enable(curChkStatus)
			self.comParity.Enable(curChkStatus)
			self.comDatabit.Enable(curChkStatus)
			self.comStopbits.Enable(curChkStatus)
			self.comFlowControl.Enable(curChkStatus)
			
	def openLogDir(self, event):  # wxGlade: qpyTools.<event_handler>
		if ifExist(PROJECT_ABSOLUTE_PATH + "\\logs"):
			p = subprocess.Popen("explorer.exe " + PROJECT_ABSOLUTE_PATH + "\\logs", shell = True)
		else:
			makeDir(PROJECT_ABSOLUTE_PATH + "\\logs")
			makeDir(PROJECT_ABSOLUTE_PATH + "\\logs\\apps")
			makeDir(PROJECT_ABSOLUTE_PATH + "\\logs\\software")
			if ifExist(PROJECT_ABSOLUTE_PATH + "\\logs"):
				p = subprocess.Popen("explorer.exe " + PROJECT_ABSOLUTE_PATH + "\\logs", shell = True)
	def srcEditorBrowse(self, event):  # wxGlade: qpyTools.<event_handler>
		self.srcEditorBrowseBtn.SetFocus()
		defDir, defFile = '', ''	#default dir/ default file
		dlg = wx.FileDialog(self, _(u'打开文件'), defDir, defFile, 'Editor (*)|*',wx.FD_OPEN | wx.FD_FILE_MUST_EXIST)
		if dlg.ShowModal()==wx.ID_CANCEL:
			return
		self.codeEditorPathText.SetValue(dlg.GetPath())

	def mpycPathChk(self, event):  # wxGlade: qpyTools.<event_handler>
		curChkStatus = self.mpycChk.GetValue()
		self.mpycPathText.Enable(curChkStatus)
		self.mpycBrowser.Enable(curChkStatus)
		
	def mpycPathBrowse(self, event):  # wxGlade: qpyTools.<event_handler>
		self.mpycBrowser.SetFocus()
		defDir, defFile = PROJECT_ABSOLUTE_PATH + "\\exes\\mpy-cross\\", ''	#default dir/ default file
		dlg = wx.FileDialog(self, _(u'打开文件'), defDir, defFile, 'mpy-cross file (*.exe)|*.exe',wx.FD_OPEN | wx.FD_FILE_MUST_EXIST)
		if dlg.ShowModal()==wx.ID_CANCEL:
			return
		self.mpycPathText.SetValue(dlg.GetPath())
		
	def initConfigFile(self, makeNewSession=False):
		rmFile(PROJECT_ABSOLUTE_PATH + "\\config.ini")
		if makeNewSession: 
			self.conf.add_section("software")
		self.conf.set("software", "autoSaveLogMaxItem", "10")
		self.conf.set("software", "autoSaveLogMaxSize", "100")
		self.conf.set("software", "codeEditorPath", "notepad.exe")
		self.conf.set("software", "codeEditorLaunchParameter", "%f")
		self.conf.set("software", "filebrowserpath", PROJECT_ABSOLUTE_PATH)
		self.conf.set("software", "language", "zh_CN")
		if makeNewSession: 
			self.conf.add_section("uart")
		self.conf.set("uart", "comBaud", "115200")
		self.conf.set("uart", "comParity", "NONE")
		self.conf.set("uart", "comDatabit", "8")
		self.conf.set("uart", "comStopbits", "1")
		self.conf.set("uart", "comFlowControl", "NONE")
		if makeNewSession:
			self.conf.add_section("mpyc")
		self.conf.set("mpyc", "mpycPath", "{{local}}\\exes\\mpy-cross\\mpy-cross-" + ("amd64" if platform.machine().endswith('64') else "win32")  + ".exe")
		if makeNewSession:
			self.conf.add_section("font")
		self.conf.set('font', 'default', 'True')
		self.conf.set('font', 'size', '12')
		self.conf.set('font', 'fontface', 'Lucida Sans Typewriter')
		self.conf.set('font', 'bold', 'False')
		self.conf.set('font', 'italic', 'False')
		self.conf.set('font', 'underline', 'False')
		self.conf.set('font', 'encoding', '33')
		self.conf.set('font', 'colour', '(255,255,255)')
		if makeNewSession:
			self.conf.add_section("QuickCMD")
		self.conf.set('QuickCMD', 'cmdcnt', '6')
		self.conf.set('QuickCMD', 'cmd1', r'NET State|import net\r\nnet.getState()\r\n')
		self.conf.set('QuickCMD', 'cmd2', r'LIST DIR|import uos\r\nuos.listdir()\r\n')
		self.conf.set('QuickCMD', 'cmd3', r'DATA CALL|import dataCall\r\ndataCall.getInfo(1,0)\r\n')
		self.conf.set('QuickCMD', 'cmd4', r'SIM Status|import sim\r\nsim.getStatus()\r\n')
		self.conf.set('QuickCMD', 'cmd5', r'IMEI|import modem\r\nmodem.getDevImei()\r\n')
		self.conf.set('QuickCMD', 'cmd6', r'QUECLOCATOR|import cellLocator\r\ncellLocator.getLocation("www.queclocator.com", 80, "1111111122222222", 8, 1)\r\n')
		with open(PROJECT_ABSOLUTE_PATH + "\\config.ini","w+", encoding='utf-8') as f:
			self.conf.write(f)

	def saveSettings(self, event):  # wxGlade: qpyTools.<event_handler>
		self.disableSettingChk()
		self.conf.set("software", "autoSaveLogMaxItem", "10" if len(self.autoSaveLogMaxItem.GetValue())==0 else self.autoSaveLogMaxItem.GetValue())
		self.conf.set("software", "autoSaveLogMaxSize", "100" if len(self.autoSaveLogMaxSize.GetValue())==0 else self.autoSaveLogMaxSize.GetValue())
		self.conf.set("software", "codeEditorPath", self.codeEditorPathText.GetValue())
		self.conf.set("software", "codeEditorLaunchParameter", self.codeEditorParam.GetValue())
		self.conf.set("software", "filebrowserpath", self.localFilePath.GetValue())
		self.conf.set("uart", "comBaud", self.comBaud.GetString(self.comBaud.GetCurrentSelection()))
		self.conf.set("uart", "comParity", self.comParity.GetString(self.comParity.GetCurrentSelection()))
		self.conf.set("uart", "comDatabit", self.comDatabit.GetString(self.comDatabit.GetCurrentSelection()))
		self.conf.set("uart", "comStopbits", self.comStopbits.GetString(self.comStopbits.GetCurrentSelection()))
		self.conf.set("uart", "comFlowControl", self.comFlowControl.GetString(self.comFlowControl.GetCurrentSelection()))
		self.conf.set("mpyc", "mpycPath", self.mpycPathText.GetValue())
		with open(PROJECT_ABSOLUTE_PATH + "\\config.ini","w+", encoding='utf-8') as f:
			self.conf.write(f)
		self.getConfigValue()
		
	def resetSettigns(self, event):  # wxGlade: qpyTools.<event_handler>
		self.disableSettingChk()
		self.initConfigFile()
		self.getConfigValue()
		self.toolBar.ToggleTool(3003, True)
		self.stcColorized(True, True, self.stc_colour)
		'''
		self.font = wx.Font(12,
								wx.MODERN,
								wx.NORMAL,
								wx.NORMAL,
								False,
								"Lucida Sans Typewriter"
						)
		for i in range(12):
			self.stc.StyleSetFont(i, self.font)
		'''
		
	def restoreSettings(self, event):  # wxGlade: qpyTools.<event_handler>
		self.disableSettingChk()
		self.getConfigValue()
		
	def getConfigValue(self):
		self.autoSaveLogMaxItem.SetValue(self.conf.get("software", "autoSaveLogMaxItem"))
		self.autoSaveLogMaxSize.SetValue(self.conf.get("software", "autoSaveLogMaxSize"))
		self.codeEditorPathText.SetValue(self.conf.get("software", "codeEditorPath"))
		self.codeEditorParam.SetValue(self.conf.get("software", "codeEditorLaunchParameter", raw=True))
		self.localFilePath.SetValue(self.conf.get("software", "filebrowserpath") if ifExist(self.conf.get("software", "filebrowserpath")) else PROJECT_ABSOLUTE_PATH)
		if self.localFilePath.GetValue()=="\\":
			self.localFilePathRoot = True
		self.fileExploreGoHandler(0)
		self.comBaud.SetSelection(0 if self.comBaud.FindString(self.conf.get("uart", "comBaud"))==-1 else self.comBaud.FindString(self.conf.get("uart", "comBaud")))
		self.comParity.SetSelection(0 if self.comParity.FindString(self.conf.get("uart", "comParity"))==-1 else self.comParity.FindString(self.conf.get("uart", "comParity")))
		self.comDatabit.SetSelection(3 if self.comDatabit.FindString(self.conf.get("uart", "comDatabit"))==-1 else self.comDatabit.FindString(self.conf.get("uart", "comDatabit")))
		self.comStopbits.SetSelection(0 if self.comStopbits.FindString(self.conf.get("uart", "comStopbits"))==-1 else self.comStopbits.FindString(self.conf.get("uart", "comStopbits")))
		self.comFlowControl.SetSelection(0 if self.comFlowControl.FindString(self.conf.get("uart", "comFlowControl"))==-1 else self.comFlowControl.FindString(self.conf.get("uart", "comFlowControl")))
		self.mpycPathText.SetValue(self.conf.get("mpyc", "mpycPath").replace("{{local}}", PROJECT_ABSOLUTE_PATH))
		'''
		self.cmdcnt = 0
		self.cmdcnt.SetValue(self.conf.get("QuickCMD", "cmdcnt"))
		print(self.cmdcnt)
		cmd_list = []
		for i in self.cmdcnt:
			CMD.SetValue(self.conf.get("QuickCMD", "CMD"+str(i)))
			cmd_list.append(CMD)
		print(cmd_list)
		'''
	
	def disableSettingChk(self):
		self.autoSaveLogChk.SetValue(False)
		self.autoSaveLogChkToggle(0)
		self.codeEditorChk.SetValue(False)
		self.codeEditorToggle(0)
		self.comSettingChk.SetValue(False)
		self.changeSerialSettingChk(0)
		self.mpycChk.SetValue(False)
		self.mpycPathChk(0)
		self.manualSettingChk.SetValue(False)
		self.manualEditConfigure(0)
		
	def txtFilterNum(self, event):  # wxGlade: qpyTools.<event_handler>
		if event.GetKeyCode() in keycodeNumber.values() or event.GetKeyCode() in keycodeCtrl.values():
			event.Skip()
		else:
			wx.Bell()
	
	curFilePathStr = ""
	def filePathHandler(self, event):  # wxGlade: qpyTools.<event_handler>
		if event.GetKeyCode() in [13, 370]:
			if self.localFilePath.GetValue()=="\\":
				self.localFilePathRoot = True
			self.fileExploreGoHandler(0)
			self.localFilePathGo.SetFocus()
		elif event.GetKeyCode() in [47, 392]: # both / sign
			self.localFilePath.AppendText("\\")
		else:
			event.Skip()
	
	def fileExploreGoHandler(self, event):  # wxGlade: qpyTools.<event_handler>
		self.FileIconList.RemoveAll()
		self.localFileList.DeleteAllItems()
		
		if self.localFilePath.GetValue()=="\\":
			self.localFilePathRoot=True
		
		# index cnt
		curCnt = 0
		if self.localFilePathRoot==False:
			# .. item for go up
			icon = self.iconLookup(">>>folder<<<")
			self.FileIconList.Add(icon)
			self.localFileList.InsertItem(curCnt, curCnt)
			self.localFileList.SetItem(curCnt, 0, "..")
			curCnt += 1
		else:
			icon = self.iconLookup(">>>driver<<<")
			for i in getDrivers():
				self.FileIconList.Add(icon)
				self.localFileList.InsertItem(curCnt, curCnt)
				self.localFileList.SetItem(curCnt, 0, " " + i)
				self.localFileList.SetItem(curCnt, 1, "-")
				self.localFileList.SetItem(curCnt, 2, "<DRV>")
				self.localFileList.SetItem(curCnt, 3, "-")
				curCnt += 1
			self.localFilePathRoot = False
			self.localFilePath.SetValue("\\")
			self.curFilePathStr = "\\"
			self.conf.set("software", "filebrowserpath", self.localFilePath.GetValue())
			with open(PROJECT_ABSOLUTE_PATH + "\\config.ini","w+", encoding='utf-8') as f:
				self.conf.write(f)
			return None
		
		while "\\\\" in self.localFilePath.GetValue():
			self.localFilePath.SetValue(self.localFilePath.GetValue().replace("\\\\", "\\"))
		
		if self.localFilePath.GetValue()=="\\" or len(self.localFilePath.GetValue())==0:
			self.localFilePath.SetValue(os.environ['HOMEDRIVE'] + "\\")
		
		self.localFilePath.SetValue(self.localFilePath.GetValue()[0:1].upper() + self.localFilePath.GetValue()[1:])
		
		if ifExist(self.localFilePath.GetValue()):
			if self.localFilePath.GetValue()[-1:]!="\\":
				self.localFilePath.AppendText("\\")
			
			self.curFilePathStr = self.localFilePath.GetValue()
			
			for i in os.walk(self.curFilePathStr, topdown=True):
				for j in i[1]:
					#print(j, time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(os.stat(self.curFilePathStr + j).st_mtime)))
					#dir
					icon = self.iconLookup(">>>folder<<<")
					self.FileIconList.Add(icon)
					self.localFileList.InsertItem(curCnt, curCnt)
					self.localFileList.SetItem(curCnt, 0, j)
					self.localFileList.SetItem(curCnt, 1, "-")
					self.localFileList.SetItem(curCnt, 2, "<DIR>")
					self.localFileList.SetItem(curCnt, 3, time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(os.stat(self.curFilePathStr + j).st_mtime)))
					curCnt += 1
				for k in i[2]:
					#print(k, sizeof_fmt(os.stat(self.curFilePathStr + k).st_size), os.path.splitext(k)[1], time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(os.stat(self.curFilePathStr + j).st_mtime)))
					#sync.ffs_db 744.6KiB .ffs_db 2020-10-01 06:08:15
					#file
					icon = self.iconLookup(os.path.splitext(k)[1].replace(".", "", 1), self.curFilePathStr + k, os.stat(self.curFilePathStr + k).st_size)
					self.FileIconList.Add(icon)
					self.localFileList.InsertItem(curCnt, curCnt)
					self.localFileList.SetItem(curCnt, 0, k)
					self.localFileList.SetItem(curCnt, 1, sizeof_fmt(os.stat(self.curFilePathStr + k).st_size))
					self.localFileList.SetItem(curCnt, 2, os.path.splitext(k)[1] + " file")
					self.localFileList.SetItem(curCnt, 3, time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(os.stat(self.curFilePathStr + k).st_mtime)))
					curCnt += 1
				break
		else:
			wx.Bell()
			return None
		#save config
		self.conf.set("software", "filebrowserpath", self.localFilePath.GetValue())
		with open(PROJECT_ABSOLUTE_PATH + "\\config.ini","w+", encoding='utf-8') as f:
			self.conf.write(f)
	
	def fileExploreReFreshHandler(self, event):  # wxGlade: qpyTools.<event_handler>
		if self.curFilePathStr=="\\":
			self.localFilePathRoot = True
		self.localFilePath.SetValue(self.curFilePathStr)
		self.fileExploreGoHandler(0)
				
	'''def OnReSize(self, event):
		event.Skip()'''
	def fileExploreGoUpHandler(self, event):  # wxGlade: qpyTools.<event_handler>
		if fatherDir(fatherDir(self.localFilePath.GetValue()))==self.localFilePath.GetValue():
			self.localFilePathRoot = True
		else:
			self.localFilePathRoot = False
			
		if ifExist(fatherDir(fatherDir(self.localFilePath.GetValue()))):
			self.localFilePath.SetValue(fatherDir(fatherDir(self.localFilePath.GetValue())))
			self.fileExploreGoHandler(0)
			
	def iconLookup(self, ext, fullPath="", filesize=0):
		if ">>>notfound<<<" not in self.fileExtIcon:
			self.fileExtIcon[">>>notfound<<<"] = wx.Icon(r"shell32.dll;0", wx.BITMAP_TYPE_ICO)
		if ">>>transparent<<<" not in self.fileExtIcon:
			self.fileExtIcon[">>>transparent<<<"] = wx.Icon(PROJECT_ABSOLUTE_PATH + "\\images\\20px.ico", wx.BITMAP_TYPE_ICO)
		# detect windows version and return none except windows 10
		if sys.getwindowsversion()[0]!=10:
			return self.fileExtIcon[">>>transparent<<<"]
		
		if ">>>folder<<<" not in self.fileExtIcon:
			self.fileExtIcon[">>>folder<<<"] = wx.Icon(r"shell32.dll;3", wx.BITMAP_TYPE_ICO)
		if ">>>driver<<<" not in self.fileExtIcon:
			self.fileExtIcon[">>>driver<<<"] = wx.Icon(r"shell32.dll;8", wx.BITMAP_TYPE_ICO)
		if ">>>imagefile<<<" not in self.fileExtIcon:
			self.fileExtIcon[">>>imagefile<<<"] = wx.Icon(r"shell32.dll;313", wx.BITMAP_TYPE_ICO)
		if ">>>videofile<<<" not in self.fileExtIcon:
			self.fileExtIcon[">>>videofile<<<"] = wx.Icon(r"shell32.dll;315", wx.BITMAP_TYPE_ICO)
		if ">>>audiofile<<<" not in self.fileExtIcon:
			self.fileExtIcon[">>>audiofile<<<"] = wx.Icon(r"shell32.dll;314", wx.BITMAP_TYPE_ICO)
		if  ">>>dllfile<<<" not in self.fileExtIcon:
			self.fileExtIcon[">>>dllfile<<<"] = wx.Icon(r"shell32.dll;72", wx.BITMAP_TYPE_ICO)
		if  ">>>exefile<<<" not in self.fileExtIcon:
			self.fileExtIcon[">>>exefile<<<"] = wx.Icon(r"shell32.dll;261", wx.BITMAP_TYPE_ICO)
		if  ">>>codefile<<<" not in self.fileExtIcon:
			self.fileExtIcon[">>>codefile<<<"] = wx.Icon(r"shell32.dll;312", wx.BITMAP_TYPE_ICO)
		if  ">>>pyfile<<<" not in self.fileExtIcon:
			self.fileExtIcon[">>>pyfile<<<"] = wx.Icon(PROJECT_ABSOLUTE_PATH + "\\images\\pyfile.ico", wx.BITMAP_TYPE_ICO)
		
		if ext=="" or len(ext)==0:
			return self.fileExtIcon[">>>notfound<<<"]
		elif ext in self.fileExtIcon:
			return self.fileExtIcon[ext]
		#todo cannot extract any icon from windows app (uwb app), photo\video\coder writer
		#use white list to avoid this situation
		elif ext.lower() in [ "png", "jpg", "gif", "jpeg", "jpe", "tiff", "tif", "bmp", "dib", "wdp", "heic", "webp", "ico", "jfif"]:
			return self.fileExtIcon[">>>imagefile<<<"]
		elif ext.lower() in ["mp4", "wmv", "mkv", "m4v", "mov", "asf", "avi", "m2ts", "3g2", "3gp2", "3gp", "3gpp"]:
			return self.fileExtIcon[">>>videofile<<<"]
		elif ext.lower() in ["mp3", "flac", "aac", "aac", "m4a", "wav", "wma", "ac3", "amr"]:
			return self.fileExtIcon[">>>audiofile<<<"]
		elif ext.lower() in ["dll"]:
			return self.fileExtIcon[">>>dllfile<<<"]
		elif ext.lower() in ["exe"]:			#todo  enable this will override all exe icon. but if exe don't have any icon will come to an error
			return self.fileExtIcon[">>>exefile<<<"]
		elif ext.lower() in [	"asp", "aspx", "asa", "asax", "ascx", "asmx", "master", "skin",\
								"cs", "lua", "h", "c", "c#", "cc", "c++", "cxx", "hh", "hxx", "css"\
								"html", "htm", "html", "shtml", "xhtml", "hta", "ass", "ssa", "ini"\
								"cpp", "hpp", "h++", "java", "js", "class", "json", "xml", "text",\
								"md", "mdown", "markdown", "pl", "pm", "php", "ps1", "rtf", "rb",\
								"sql", "txt", "log", "cfg", "srt", "properties", "xsd", "xslt", "xsl" ,\
								"vbs", "vb", "bas", "xaml", "svg", "atom", "rss", "csproj", "vbproj",\
								"lnk","psd","pdf","wxg"]:
			return self.fileExtIcon[">>>codefile<<<"]
		elif ext.lower()=="py":
			return self.fileExtIcon[">>>pyfile<<<"]
		# elif ext.lower()=="exe":
			# if fullPath!="":
				# if filesize<200000:	#file size no bigger than 200k, don't get icon
					# return self.fileExtIcon[">>>dllfile<<<"]
				# iconCache = wx.Icon(fullPath, wx.BITMAP_TYPE_ICO)
				# if iconCache.IsOk():
					# return iconCache
				# else:
					# return self.fileExtIcon[">>>dllfile<<<"]
			# else:
				# return self.fileExtIcon[">>>dllfile<<<"]
		
		fileType = wx.TheMimeTypesManager.GetFileTypeFromExtension(ext)
			
		if fileType is None:
			return self.fileExtIcon[">>>notfound<<<"]
		else:
			info = fileType.GetIconInfo()

			'''print(info)
			print(fileType.GetDescription())
			print(fileType.GetExtensions())
			print(fileType.GetMimeType())
			print(fileType.GetMimeTypes())'''

			if info != None:
				icon, file, idx = info
				if icon:
					if ext.lower()!="exe":
						self.fileExtIcon[ext] = icon
					return icon
				else:
					return self.fileExtIcon[">>>notfound<<<"]
		return None			
		
	def winTabChanged(self, event):  # wxGlade: qpyTools.<event_handler>
		if self.notebook_1.GetSelection()==0:
			self.stc.SetFocus()
		elif self.notebook_1.GetSelection()==1:
			self.localFilePath.SetFocus()
		elif self.notebook_1.GetSelection()==2:
			self.firmwareBrowser.SetFocus()
		elif self.notebook_1.GetSelection()==3:
			self.autoSaveLogChk.SetFocus()

	def localFileListDoubleClickHandler(self, event):  # wxGlade: qpyTools.<event_handler>
		currentItem = event.GetIndex()

		#special item, go up operation
		if currentItem==0 and self.localFileList.GetItemText(currentItem, 0)=="..":
			self.fileExploreGoUpHandler(0)
			return None
		
		if self.localFileList.GetItemText(currentItem, 2)=="<DIR>":
			self.curFilePathStr = self.curFilePathStr + self.localFileList.GetItemText(currentItem, 0).strip() + "\\"
			self.fileExploreReFreshHandler(0)
		elif self.localFileList.GetItemText(currentItem, 2)=="<DRV>":
			self.curFilePathStr = self.localFileList.GetItemText(currentItem, 0).strip() + "\\"
			self.fileExploreReFreshHandler(0)
		else:
			p = subprocess.Popen("explorer.exe " + self.curFilePathStr + self.localFileList.GetItemText(currentItem, 0), shell = True)
			
		
	def menuHandler(self, event):  # wxGlade: qpyTools.<event_handler>
		global languageTab
		if event.GetId()==2002:	#menu exit
			wx.Exit()
			self.Close(True)
		elif event.GetId()==2001:	#menu save file
			self.saveLogFunc()
		elif event.GetId()==2011:
			self.notebook_1.SetSelection(0)
		elif event.GetId()==2012:
			self.notebook_1.SetSelection(1)
		elif event.GetId()==2013:
			self.notebook_1.SetSelection(2)
		elif event.GetId()==2014:
			self.notebook_1.SetSelection(3)
		elif event.GetId()==2021:
			self.languageTabFunc('zh_CN')
		elif event.GetId()==2022:
			self.languageTabFunc('en')
		elif event.GetId()==2031:
			self.notebook_1.SetSelection(0)
		elif event.GetId()==2032:	#menu save file
			self.saveLogFunc()
		elif event.GetId()==2041:
			#os.system("explorer.exe " + PROJECT_ABSOLUTE_PATH + "\\logs\\software\\")
			p = subprocess.Popen("explorer.exe " + PROJECT_ABSOLUTE_PATH + "\\logs\\software\\", shell=True)
		elif event.GetId()==2042:
			#os.system("explorer.exe " + PROJECT_ABSOLUTE_PATH + "\\logs\\software\\")
			p = subprocess.Popen("explorer.exe " + PROJECT_ABSOLUTE_PATH + "\\logs\\apps\\", shell=True)
		elif event.GetId()==2051:
			#os.system("explorer.exe http://python.quectel.com")
			webbrowser.open("http://python.quectel.com", new = 2)
		elif event.GetId()==2052:
			#os.system("explorer.exe http://python.quectel.com/wiki")
			webbrowser.open("http://python.quectel.com/wiki", new = 2)
		elif event.GetId()==2053:
			#os.system("explorer.exe http://python.quectel.com/index.html#video")
			webbrowser.open("https://python.quectel.com/videoList", new = 2)
		elif event.GetId()==2054:
			webbrowser.open("https://jq.qq.com/?_wv=1027&k=p5D7qq4j", new = 2)
		elif event.GetId()==2055:
			webbrowser.open("https://python.quectel.com/download", new = 2)
		elif event.GetId()==2061:
			thread_process_handle()
		elif event.GetId()==2062:
			if languageTab == "zh_CN":
				webbrowser.open("https://www.quectel.com/cn/", new = 2)
			else:
				webbrowser.open("https://www.quectel.com/", new = 2)
		elif event.GetId()==2063:
			webbrowser.open("http://python.quectel.com", new = 2)
		elif event.GetId()==2064:
			wx.MessageDialog(None, _(u"工具当前版本:   QPYcom_V")+versionGlobal, _(u"工具版本"), wx.OK).ShowModal()
		elif event.GetId()==2065:
			p = subprocess.Popen("explorer.exe " + PROJECT_ABSOLUTE_PATH + "\\docs\\", shell=True)
		elif event.GetId()==2066:
			p = subprocess.Popen("explorer.exe " + PROJECT_ABSOLUTE_PATH + "\\docs\\", shell=True)
	#save languageconfig
	def languageTabFunc(self,language):
		self.conf.set("software", "languagetab", language)
		with open(PROJECT_ABSOLUTE_PATH + "\\config.ini","w+", encoding='utf-8') as f:
			self.conf.write(f)
			
		wx.MessageBox(_(u'语言已切换，请重启程序'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		# dlg = wx.MessageDialog(None,_(u'语言已切换，请重启程序'), _(u'提示'), wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
		# if dlg.ShowModal() == 5103:
		#	 wx.Exit()
		#	 self.Close(True)
		# 	 sys.exit()
	def saveLogFunc(self):
		defDir, defFile = '', ''	#default dir/ default file
		dlg = wx.FileDialog(self, _(u'打开文件'), defDir, defFile, 'Log File (*)|*', wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)
		if dlg.ShowModal()==wx.ID_OK:
			self.stc.SaveFile(dlg.GetPath())
			return True
		else:
			return False
	def modFileRefreshFunc(self, event):  # wxGlade: qpyTools.<event_handler>
		global ser, serProcessing, serProctype, serProceOnce, serProcTmpVar,q
		# start to fresh mod file
		if ser.isOpen():
			# and serProceOnce == False 解决刷新堵塞的问题(展锐平台数据缺失问题影响使用体验)
			if serLastRecvData.decode("utf-8", errors="ignore").endswith(">>> ") or serLastRecvTime==0:
				if serProcessing == False:
					serProcessing = True
					serProctype = "ls"
					serProceOnce = False
					serProcTmpVar = None
					# self.ser.write(b"\r\x03\x03")	# ctrl-C twice: interrupt any running program
					q.queue_put(-1, _(u"模块文件列表刷新中"), 5)
				else:
					wx.MessageBox(_(u'刷新按钮频率太快啦，请重试！\r\n若重新刷新无效请重新打开串口或在交互页面回车后重试'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			else:
				wx.MessageBox(_(u'Python 代码运行输出中,请检查交互是否有代码运行中\r\n如需停止运行，请等待程序结束，或者重新刷写固件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		else:
			wx.MessageBox(_(u'请先打开串口'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		
	def modFileAddFunc(self, event):  # wxGlade: qpyTools.<event_handler>
		global ser, serProcessing, serProctype, serProceOnce, serProcTmpVar, nowTotalFileSize
		
		if ser.isOpen():
			if serLastRecvData.decode("utf-8", errors="ignore").endswith(">>> ") or serLastRecvTime==0:
				defDir, defFile = '', ''	#default dir/ default file
				dlg = wx.FileDialog(self, _(u'打开文件'), defDir, defFile, 'File (*)|*',wx.FD_OPEN | wx.FD_FILE_MUST_EXIST)
				if dlg.ShowModal()==wx.ID_CANCEL:
					return
				fizeSize = getFileSize(dlg.GetPath())
				if fizeSize > maxFileSize - nowTotalFileSize:
					wx.MessageBox(_(u'选择小于5MB的文件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
					return
				serProcessing = True
				serProctype = "downloadFile"
				serProceOnce = False
				serProcTmpVar = dlg.GetPath()
			else:
				wx.MessageBox(_(u'Python 代码运行输出中,请检查交互是否有代码运行中\r\n如需停止运行，请等待程序结束，或者重新刷写固件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		else:
			wx.MessageBox(_(u'请先打开串口'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		
	def modFileRmFunc(self, event):  # wxGlade: qpyTools.<event_handler>
		global ser, serProcessing, serProctype, serProceOnce, serProcTmpVar, protectFile
		
		if ser.isOpen():
			if serLastRecvData.decode("utf-8", errors="ignore").endswith(">>> ") or serLastRecvTime==0:
				if self.modFileTree.GetSelection().IsOk():
					itemID = self.modFileTree.GetSelection()
					if itemID == self.modFileTree.RootItem:
						wx.MessageBox(_(u'根目录不可删除！ '), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
						return None
					itemPathList = self.getItemPathList(itemID, self.modFileTree)
					del itemPathList[0]
					
					if itemPathList[0] in protectFile:
						wx.MessageBox(_(u'配置文件不可删除! '), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
					else:
						serProcTmpVar = "/".join(itemPathList)
						# print("serProcTmpVar",serProcTmpVar)
						serProcessing = True
						serProctype = "rmFile"
						serProceOnce = False
				else:
					wx.MessageBox(_(u'错误的文件选择，请重试'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			else:
				wx.MessageBox(_(u'Python 代码运行输出中,请检查交互是否有代码运行中\r\n如需停止运行，请等待程序结束，或者重新刷写固件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		else:
			wx.MessageBox(_(u'请先打开串口'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		
	def modFileRunFunc(self, event):  # wxGlade: qpyTools.<event_handler>
		global ser, serProcessing, serProctype, serProceOnce, serProcTmpVar
		
		if ser.isOpen():
			if self.modFileTree.GetSelection().IsOk():
				if self.modFileTree.GetItemText(self.modFileTree.GetSelection())[-2:].lower()!="py":
					wx.MessageBox(_(u'请选择 python(.py) 文件运行'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
				else:
					itemID = self.modFileTree.GetSelection()
					itemPathList = self.getItemPathList(itemID, self.modFileTree)
					#print(itemPathList)
					del itemPathList[0]
					serProcTmpVar = "/".join(itemPathList)
					serProcessing = True
					serProctype = "execFile"
					serProceOnce = False
					self.notebook_1.SetSelection(0)
		else:
			wx.MessageBox(_(u'请先打开串口'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)

	def modFileCleanFunc(self, event):  # wxGlade: qpyTools.<event_handler>
		global ser, serProcessing, serProctype, serProceOnce, serProcTmpVar, protectFile
		
		if ser.isOpen():
			if serLastRecvData.decode("utf-8", errors="ignore").endswith(">>> ") or serLastRecvTime==0:
				if self.modFileTree.GetSelection().IsOk():					
					itemPathList = self.getItemList(self.modFileTree)				
					del itemPathList[0]
					itemPathListClean = [x for x in itemPathList if x not in protectFile]
					serProcTmpVar = itemPathListClean
					serProcessing = True
					serProctype = "cleanFile"
					serProceOnce = False
				else:
					wx.MessageBox(_(u'错误的文件选择，请重试'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			else:
				wx.MessageBox(_(u'Python 代码运行输出中,请检查交互是否有代码运行中\r\n如需停止运行，请等待程序结束，或者重新刷写固件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		else:
			wx.MessageBox(_(u'请先打开串口'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)

		
	def fileListDragInit(self, event):  # wxGlade: qpyTools.<event_handler>
		text = self.localFileList.GetItemText(event.GetIndex())
		tobj = wx.TextDataObject(text)
		src = wx.DropSource(self.localFileList)
		src.SetData(tobj)
		src.DoDragDrop(True)
	# modFile RIGHT CLICK EVENT
	def modFileTreeRightClick(self, event):
		self.modFileTree.SetFocusedItem(event.GetItem())
		raw_app_path = r'%s' %'/usr/' + self.modFileTree.GetItemText(self.modFileTree.GetFocusedItem())
		# print(raw_app_path)	
		menu = wx.Menu()
		if self.modFileTree.GetChildrenCount(event.GetItem()) > 0:
			add = wx.MenuItem(menu, 7001, _(u"新增文件"))
			menu.Append(add)
			self.Bind(wx.EVT_MENU, self.modFileAddByPopupFunc, add)
			add = wx.MenuItem(menu, 7002, _(u"新建文件夹"))
			menu.Append(add)
			self.Bind(wx.EVT_MENU, self.modFileAddFolderFunc, add)
		delete = wx.MenuItem(menu, 7003, _(u"删除"))
		# if self.modFileTree.SetFocusedItem(event.GetItem()) == self.modFileTree.RootItem:
			# delete.Enable(enable = False) 
		menu.Append(delete)
		self.Bind(wx.EVT_MENU, self.modFileRmFunc, delete)
		# property = wx.MenuItem(menu, 7004, _(u"属性"))
		# property.Enable(enable = False)
		# menu.Append(property)
		self.PopupMenu(menu)
		self.Bind(wx.EVT_MENU, self.modFilePropertyFunc, property)
		menu.Destroy()	
		
	def modFileAddByPopupFunc(self, event):
		global ser, serProcessing, serProctype, serProceOnce, serProcTmpVar, serProPathStr, nowTotalFileSize
		
		if ser.isOpen():
			if serLastRecvData.decode("utf-8", errors="ignore").endswith(">>> ") or serLastRecvTime==0:
				defDir, defFile = '', ''	#default dir/ default file
				dlg = wx.FileDialog(self, _(u'打开文件'), defDir, defFile, 'File (*)|*',wx.FD_OPEN | wx.FD_FILE_MUST_EXIST)
				if dlg.ShowModal()==wx.ID_CANCEL:
					return
				fizeSize = getFileSize(dlg.GetPath())
				if fizeSize > maxFileSize - nowTotalFileSize:
					wx.MessageBox(_(u'选择小于5MB的文件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
					return
				id = self.modFileTree.GetFocusedItem()
				pathStr = self.modFileTree.GetItemText(id)
				# Gets the absolute path based on the current itemID
				if id == self.modFileTree.GetRootItem():
					pathStr = ""								
				else:
					while True:
						id = self.modFileTree.GetItemParent(id)
						if id == self.modFileTree.GetRootItem():
							break
						pathStr = self.modFileTree.GetItemText(id)+ "/" + pathStr
				serProcessing = True
				serProctype = "downloadFile"
				serProceOnce = False
				serProcTmpVar = dlg.GetPath()
				serProPathStr = pathStr
			else:
				wx.MessageBox(_(u'Python 代码运行输出中,请检查交互是否有代码运行中\r\n如需停止运行，请等待程序结束，或者重新刷写固件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		else:
			wx.MessageBox(_(u'请先打开串口'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
		
	def modFileAddFolderFunc(self, event):
		global ser, serProcessing, serProctype, serProceOnce, serProcTmpVar, serProPathStr
		dlg = wx.TextEntryDialog(self, _(u"输入文件夹名称:"), _(u"新建文件夹"), '', wx.OK|wx.CANCEL)
		if dlg.ShowModal() == wx.ID_OK:
			if ser.isOpen():
				if serLastRecvData.decode("utf-8", errors="ignore").endswith(">>> ") or serLastRecvTime == 0:
					id = self.modFileTree.GetFocusedItem()
					pathStr = self.modFileTree.GetItemText(id)
					# Gets the absolute path based on the current itemID
					if id == self.modFileTree.GetRootItem():
						pathStr = ""								
					else:
						while True:
							id = self.modFileTree.GetItemParent(id)
							if id == self.modFileTree.GetRootItem():
								break
							pathStr = self.modFileTree.GetItemText(id)+ "/" + pathStr
					serProcessing = True
					serProctype = "addFolder"
					serProceOnce = False
					serProcTmpVar = dlg.GetValue()
					serProPathStr = pathStr
					print(serProcTmpVar,serProPathStr)
				else:
					wx.MessageBox(_(u'Python 代码运行输出中,请检查交互是否有代码运行中\r\n如需停止运行，请等待程序结束，或者重新刷写固件'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
			else:
				wx.MessageBox(_(u'请先打开串口'), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
	def modFilePropertyFunc(self, event):
		pass
		
	def openEditor(self, event):
		app_path = (self.localFilePath.GetLineText(0) +
					self.localFileList.GetItemText(event.GetIndex()))
		raw_app_path = r'%s' %app_path
		file_path = self.codeEditorPathText.GetLineText(0)
		raw_file_path = r'%s' %file_path
		self.PopupMenu(EditFilePopup(self, raw_app_path, raw_file_path))

	def openEditorFromDownload(self, event):
		app_path = (self.localFilePath.GetLineText(0) +
					self.localFileList.GetItemText(event.GetIndex()))
		raw_app_path = r'%s' %app_path
		file_path = self.codeEditorPathText.GetLineText(0)
		raw_file_path = r'%s' %file_path
		self.PopupMenu(EditFilePopup(self, raw_app_path, raw_file_path))

	def modFileTreeExpand(self, event):  # wxGlade: qpyTools.<event_handler>
		global serProcessing, serProctype, serProceOnce, serProcTmpVar,fw_versionFlag
		self.nowTreeCtrl = event.GetEventObject()
		self.itemTmpID = event.GetItem()
		#print(self.nowTreeCtrl.GetItemText(self.itemTmpID))
		if self.nowTreeCtrl.GetItemText(self.itemTmpID)[:4] == 'Root':
			return
		self.nowTreeCtrl.DeleteChildren(self.itemTmpID)
		serProcTmpVar = self.nowTreeCtrl.GetItemText(self.itemTmpID)
		tmp = self.itemTmpID
		while True:
			tmp = self.nowTreeCtrl.GetItemParent(tmp)
			if tmp == self.nowTreeCtrl.GetRootItem():
				break
			serProcTmpVar = self.nowTreeCtrl.GetItemText(tmp)+ "/" + serProcTmpVar
		
		# if fw_versionFlag:
			# serProcTmpVar = "usr/" + serProcTmpVar
		#print(self.getItemPathList(event.GetId(), self.modFileTree))
		print(serProcTmpVar)
		serProcessing = True	#continue "lsmore" operation todo expand dir
		serProctype = "lsmore"
		serProceOnce = False
		return
		
	# Gets the absolute path based on the current itemID
	def iterateGetPath(self,tree,itemID):
		pathStr = self.tree.GetItemText(self.itemID)
		while True:
			self.itemID = self.tree.GetItemParent(itemID)
			if self.itemID == self.tree.GetRootItem():
				break
			pathStr = self.nowTreeCtrl.GetItemText(tmp)+ "/" + pathStr
			
	def modFileTreeMouseMotion(self, event):
		item, flags = self.modFileTree.HitTest(event.GetPosition())
		if flags & wx.TREE_HITTEST_ONITEMLABEL:
			try:
				size = self.modFileDict[self.modFileTree.GetItemText(item).strip()]["size"]
				size = sizeof_fmt(int(size))
				self.modFileTree.SetToolTip(str(size))
			except:
				self.modFileTree.SetToolTip("")
		else:
			self.modFileTree.SetToolTip("")
		event.Skip()

# end of class qpyTools



class fileOperation:
	def __init__(self):
		pass
	
	# def fs_ls(self):
		# global ser

		# ser.write(b"import uos\r\nprint(uos.listdir())\r\n")
		ser.write(b"\x04")
		# time.sleep(0.1)
		# a = ser.read_until(b">>> \r\n")
		# print(a)
		# a = literal_eval(a.lstrip(b"import uos\r\n>>> print(uos.listdir())\r\n").rstrip(b"\r\n>>> \r\n").decode())
		# print(a)
		# sys.exit(0)
		# return a

	def fs_download(self,tmpFileSize,totalFileSize,fileName_path):
		time.sleep(0.5)
		print('THIS IS ADDING: ', fileName_path)
		global ser, fw_versionFlag, statusBarStr
		if fw_versionFlag:
			ser.write(("f=open('/usr/" + repr(extractFileName(fileName_path).encode("utf-8", errors="ignore"))[2:-1] + "','wb',encoding='utf-8')\r\n").encode("utf-8") + b"w=f.write\r\n")
			# print("fs_download", ("f=open('/usr/" + repr(extractFileName(fileName_path).encode("utf-8", errors="ignore"))[2:-1] + "','wb',encoding='utf-8')\r\n").encode("utf-8"))
		else:
			ser.write(("f=open('" + repr(extractFileName(fileName_path).encode("utf-8", errors="ignore"))[2:-1] + "','wb',encoding='utf-8')\r\n").encode("utf-8") + b"w=f.write\r\n")
			# print("fs_download", ("f=open('" + repr(extractFileName(fileName_path).encode("utf-8", errors="ignore"))[2:-1] + "','wb',encoding='utf-8')\r\n").encode("utf-8"))
		tmpSndCnt = 0
		with open(fileName_path, "rb") as f:
			while True:
				data = f.read(255)
				if not data:
					break
				else:
					ser.write(b"w(" + repr(data).encode("utf-8", errors="ignore") + b")\r\n")
					tmpSndCnt+=1					
					if (255*tmpSndCnt+tmpFileSize)/totalFileSize<=1:
						print(_(u"下载进度: ") + str("%.2f%%" % ((255*tmpSndCnt+tmpFileSize)/totalFileSize*100)))
						statusBarStr = extractFileName(fileName_path) + " " + _(u"下载进度: ") + str("%.2f%%" % ((255*tmpSndCnt+tmpFileSize)/totalFileSize*100))
						#q.queue_put(-1, extractFileName(fileName_path) + " " + _(u"下载进度: ") + str("%.2f%%" % ((255*tmpSndCnt+tmpFileSize)/totalFileSize*100)), 4)
						pub.sendMessage('updateProgress', arg1= (255*tmpSndCnt+tmpFileSize)/totalFileSize*100)
						time.sleep(0.05)
					else:
						statusBarStr = extractFileName(fileName_path) + " " + _(u"下载进度: ") + str("100%")
						print(statusBarStr)
						pub.sendMessage('updateProgress', arg1= 100)
									
		ser.write(b"f.close()\r\n")
		# ser.write(b"\x04")

	def fs_remove(self, fileName):
		print('THIS IS REMOVING: ', fileName)
		global ser
		ser.write(b"import uos\r\n")
		if fw_versionFlag:
			ser.write(("uos.remove('usr/" + repr(fileName.encode("utf-8", errors="ignore"))[2:-1] + "')\r\n").encode("utf-8"))
		else:
			ser.write(("uos.remove('" + repr(fileName.encode("utf-8", errors="ignore"))[2:-1] + "')\r\n").encode("utf-8"))
		# ser.write(b"\x04")
## SLOBODAN ##

#detect serialport
class serialDet(threading.Thread):
	def __init__(self):
		threading.Thread.__init__(self)
		
	def run(self):
		global serialList,deviceList
		while True:
			deviceList= [i.device for i in serPort.comports()]
			if serialList==[] or serialList!=serPort.comports():
				if serialStatus==False:
					serialList = serPort.comports()
					pub.sendMessage('uiUpdate', arg1="serListUpd", arg2=serialList)
					pub.sendMessage('statusBarUpdate', arg1="serListUpd")
			time.sleep(1)
					
class serialKeepStatus(threading.Thread):
	def __init__(self):
		threading.Thread.__init__(self)
		
	def run(self):
		global ser, num,serLastRecvTime,serProctype,serProcessing, serProceOnce
		while num == 0:
			RecvTime = time.time()
			time.sleep(.2)
			if serProctype == "exec":
				if round(RecvTime-serLastRecvTime) > 5:
					serProceOnce = False
					#print(round(RecvTime-serLastRecvTime))
				
			time.sleep(1)
					
class serialOperation(threading.Thread):
	def __init__(self):
		threading.Thread.__init__(self)
		
	def run(self):
		global ser, deviceList,serProcessing, serProctype, serProceOnce, serProcTmpVar, protectFileStr, fw_versionFlag, serProPathStr
		global statusBarStr
		#todo
		# 1.use pubsub function
		# 2.set timeout
		# 3.last receive time
		while True:
			time.sleep(.2)
			if serProcessing:
				#refresh tree
				if serProctype == "getVersion" and serProceOnce==False:
					#print("list mod file")
					ser.write(b"import uos\r\n")
					ser.write(b"for f in uos.ilistdir('/'):\r\n")
					ser.write(b" print('>>>file<<<', f)\r\n")
					ser.write(b"\r\n")
					ser.write(b"\r\n")
					ser.write(b"\r\n")
					serProceOnce = True
					serProcessing = True
				if serProctype=="ls" and serProceOnce==False:
					#print("list mod file")
					ser.write(b"import uos\r\n")
					if fw_versionFlag:
						ser.write(b"for f in uos.ilistdir('/usr'):\r\n")
					else:
						ser.write(b"for f in uos.ilistdir('/'):\r\n")
					ser.write(b" print('>>>file<<<', f)\r\n")
					ser.write(b"\r\n")
					ser.write(b"\r\n")
					ser.write(b"\r\n")
					serProceOnce = True
					serProcessing = True
				if serProctype=="lsmore" and serProceOnce==False:
					#print("list mod file more")
					ser.write(b"import uos\r\n")
					ser.write(("for f in uos.ilistdir('/usr/" + serProcTmpVar + "/'):\r\n").encode("utf-8"))
					ser.write(b" print('>>>file<<<', f)\r\n")
					ser.write(b"\r\n")
					ser.write(b"\r\n")
					ser.write(b"\r\n")
					serProceOnce = True
					serProcessing = True
				if serProctype=="downloadFile" and serProceOnce==False:
					compileInfo = 'pysuccess'
					if repr(extractFileName(serProcTmpVar).encode("utf-8", errors="ignore"))[-4:-1] == '.py':
						try:
							source = open(serProcTmpVar,'r',encoding="utf-8").read() + '\n'
							compile(source, serProcTmpVar, 'exec')
							# source = re.sub(re.compile("#.*?\n"), "\n", source)
							#print(source)
						except:
							compileInfo = sys.exc_info()
					if compileInfo == 'pysuccess':
						print('THIS IS ADDING: ', serProcTmpVar)
						#todo
						#1. add a progressbar(on statusbar?)   2.disable others operation and button   3.opeation timeout reset vars
						#4. calc size, if max than 1MB, messagebox and do not download file.
						#ser.write("f=open('/\\xe6\\x96\\xb0\xe5\xbb\xba9.txt','wb')\r\n".encode("utf-8"))
						#ser.write(("f=open('/" + repr("新建999".encode("utf-8"))[2:-1] + "','wb')\r\n").encode("utf-8"))
						
						# ser.write(b"import uos\r\n")
						# ser.write(b"c = uos.statvfs('/usr')\r\n")
						# time.sleep(0.1)
						# ser.reset_input_buffer()
						# ser.write(b"c\r\n")
						# bytes_read = ser.read_until(b"\r\n>>>")
						# statfs = literal_eval(bytes_read.lstrip(b"c\r\n").rstrip(b"\r\n>>>").decode())
						# print(statfs)
						# free_mem = statfs[0] * statfs[3]
						# print(free_mem)
						

						# if tmpFileSize > free_mem:
						#	 wx.MessageBox('Download completed', 'Info', wx.OK | wx.ICON_INFORMATION)
						#	 break

						if serProPathStr == "":
							if fw_versionFlag:
								ser.write(("f=open('/usr/" + repr(extractFileName(serProcTmpVar).encode("utf-8", errors="ignore"))[2:-1] + "','wb')\r\n").encode("utf-8"))
							else:
								ser.write(("f=open('" + repr(extractFileName(serProcTmpVar).encode("utf-8", errors="ignore"))[2:-1] + "','wb')\r\n").encode("utf-8"))
						else:
							if fw_versionFlag:
								ser.write(("f=open('/usr/" + serProPathStr + '/'+ repr(extractFileName(serProcTmpVar).encode("utf-8", errors="ignore"))[2:-1] + "','wb')\r\n").encode("utf-8"))
							else:
								ser.write(("f=open('" + serProPathStr + '/'+ repr(extractFileName(serProcTmpVar).encode("utf-8", errors="ignore"))[2:-1] + "','wb')\r\n").encode("utf-8"))
						ser.write(b"w=f.write")
						ser.write(b"\r\n")
						
						tmpFileSize = getFileSize(serProcTmpVar)
						tmpSndCnt = 0
						statusBarStr = _(u"开始下载")
						with open(serProcTmpVar, "rb") as f:
							# remove comment for py file
							# if repr(extractFileName(serProcTmpVar).encode("utf-8", errors="ignore"))[-4:-1] == '.py':
								# for i in range(len(source)//255 + 1):
									# if i == len(source)//255:
										# data = source[i*255:len(source)]
									# else:
										# data = source[i*255:(i+1)*255]
									# time.sleep(0.03)
									# ser.write(b"w(b'999')\r\n")
									# ser.write(b"w(" + repr(data).encode("utf-8", errors="ignore") + b")\r\n")
									# print(b"w(" + repr(data).encode("utf-8", errors="ignore") + b")")
									# tmpSndCnt+=1
									# if 255*tmpSndCnt/len(source)<=1:
										# statusBarStr = extractFileName(serProcTmpVar) + " " + _(u"下载进度: ") + str("%.2f%%" % (255*tmpSndCnt/len(source)*100))
										# print(statusBarStr)
									# else:
										# statusBarStr = extractFileName(serProcTmpVar) + " " + _(u"下载进度: ") + str("100%")
							# else:
							while True:
								data = f.read(255)
								time.sleep(0.05)
								if ser.port not in deviceList:
									continueFlag = False
									break								
								if not data:
									continueFlag = True
									break
								else:
									try:
										#ser.write(b"w(b'999')\r\n")									
										ser.write(b"w(" + repr(data).encode("utf-8", errors="ignore") + b")\r\n")								
										#print(b"w(" + repr(data).encode("utf-8", errors="ignore") + b")")
										tmpSndCnt+=1
										if 255*tmpSndCnt/tmpFileSize<=1:
											statusBarStr = extractFileName(serProcTmpVar) + " " + _(u"下载进度: ") + str("%.2f%%" % (255*tmpSndCnt/tmpFileSize*100))
										else:
											statusBarStr = extractFileName(serProcTmpVar) + " " + _(u"下载进度: ") + str("100%")
									except Exception as e:
										print('下载文件异常,串口交互失败'+str(e))
						ser.write(b"f.close()\r\n")					
						time.sleep(1)
						statusBarStr = ""
						serProPathStr == ""
						if continueFlag:
							serProcessing = True	#continue "ls" operation
							serProceOnce = False
							serProcTmpVar = None
							serProctype = "ls"
						# send file done, refresh tree
						# syntax error
					else:
						wx.MessageBox((_(u'语法错误')+str(compileInfo[0])+":"+str(compileInfo[1])), _(u'提示'), wx.YES_DEFAULT | wx.ICON_INFORMATION)
						serProcessing = True	#continue "ls" operation
						serProceOnce = False
						serProcTmpVar = None
						serProctype = "ls"
										
				if  serProctype=="addFolder" and serProceOnce==False:
					print('THIS IS ADDING FOLDER: ', serProcTmpVar)
					ser.write(b"import uos\r\n")
					ser.write(("uos.mkdir('/usr/" + serProPathStr + '/'+ repr(serProcTmpVar.encode("utf-8", errors="ignore"))[2:-1] + "')\r\n").encode("utf-8"))
					time.sleep(.5)
					serProcessing = True	#continue "ls" operation
					serProceOnce = False
					serProcTmpVar = None
					serProctype = "ls"
					#add folder done, refresh tree
				if serProctype=="rmFile" and serProceOnce==False:
					print('THIS IS REMOVING: ', serProcTmpVar)
					ser.write(b"import uos\r\n")
					if fw_versionFlag:
						ser.write(("uos.remove('usr/" + repr(serProcTmpVar.encode("utf-8", errors="ignore"))[2:-1] + "')\r\n").encode("utf-8"))
						ser.write(("uos.rmdir('usr/" + repr(serProcTmpVar.encode("utf-8", errors="ignore"))[2:-1] + "')\r\n").encode("utf-8"))
					else:
						ser.write(("uos.remove('/" + repr(serProcTmpVar.encode("utf-8", errors="ignore"))[2:-1] + "')\r\n").encode("utf-8"))
						ser.write(("uos.rmdir('/" + repr(serProcTmpVar.encode("utf-8", errors="ignore"))[2:-1] + "')\r\n").encode("utf-8"))
					time.sleep(1)
					serProcessing = True	#continue "ls" operation
					serProceOnce = False
					serProcTmpVar = None
					serProctype = "ls"
					#send file done, refresh tree
				if serProctype=="cleanFile" and serProceOnce==False:
					for i in serProcTmpVar:
						print('THIS IS REMOVING: ', i)
						statusBarStr = "REMOVING: " + i
						ser.write(b"import uos\r\n")
						if fw_versionFlag:
							ser.write(("uos.remove('usr/" + repr(i.encode("utf-8", errors="ignore"))[2:-1] + "')\r\n").encode("utf-8"))
							ser.write(("uos.rmdir('usr/" + repr(i.encode("utf-8", errors="ignore"))[2:-1] + "')\r\n").encode("utf-8"))
						else:
							ser.write(("uos.remove('/" + repr(i.encode("utf-8", errors="ignore"))[2:-1] + "')\r\n").encode("utf-8"))
							ser.write(("uos.rmdir('/" + repr(i.encode("utf-8", errors="ignore"))[2:-1] + "')\r\n").encode("utf-8"))
						time.sleep(1)
					statusBarStr = ""
					serProcessing = True	#continue "ls" operation
					serProceOnce = False
					serProcTmpVar = None
					serProctype = "ls"

				if serProctype=="execFile" and serProceOnce==False:
					# print(serProcTmpVar)
					# if serProcTmpVar == "main.py":
						# flag_block_download = True
					ser.write(b"import example\r\n")
					if fw_versionFlag:
						ser.write(b"example.exec('usr/" + serProcTmpVar.encode("utf-8", errors="ignore") + b"')\r\n")
					else:
						ser.write(b"example.exec('" + serProcTmpVar.encode("utf-8", errors="ignore") + b"')\r\n")
					#print(b"example.exec('" + serProcTmpVar.encode("utf-8", errors="ignore") + b"')\r\n")
					
					
					serProctype = "exec"
					serProcessing = False	#no need to process next step, so stop
					serProceOnce = True
					serProcTmpVar = None

				# if serProctype=="protectFile" and serProceOnce==False:	
					# for i in protectFileStr:
						# if fw_versionFlag:						
								# ser.write(("f=open('/usr/" + i + "','r')\r\n").encode("utf-8"))
						# else:
								# ser.write(("f=open('" + i + "','r')\r\n").encode("utf-8"))
						# ser.write(b"print(f.read())")
						# ser.write(b"\r\n")
						# ser.write(b"\r\n")
						# ser.write(b"f.close()\r\n")
					# serProceOnce = True
					# serProcessing = True
					
				if serProctype=="QuickCMDInfo" and serProceOnce==False:
					# print(serProcTmpVar.split("\\r\\n"))
					for i in range(len(serProcTmpVar.split("\\r\\n"))-1):
						ser.write((serProcTmpVar.split("\\r\\n")[i]+"\r\n").encode("utf-8"))	
					ser.write(b"\r\n")

					serProcessing = False	#no need to process next step, so stop
					serProceOnce = False
					serProcTmpVar = None
					
		
					
					
					
class mainFrame(wx.App):

	# i18n language init
	global languageTab
	languageConfig = configparser.ConfigParser(interpolation=None)
	
	languageTab =  locale.getdefaultlocale()[0]

	
	try:
		if not ifExist(PROJECT_ABSOLUTE_PATH+"\\config.ini"):
			if languageTab == "zh_CN":
				t = gettext.translation('Chinese', 'locale', languages=["zh_CN"])
				t.install()
			elif languageTab == "en":
				t = gettext.translation('English', PROJECT_ABSOLUTE_PATH + "\\locale", languages=["en"])
				t.install()
			else:
				languageTab = "en"
				t = gettext.translation('English', PROJECT_ABSOLUTE_PATH + "\\locale", languages=["en"])
				t.install()
		else:
			languageConfig.read(PROJECT_ABSOLUTE_PATH+"\\config.ini",encoding='utf-8')
			if languageConfig.get("software", "languageTab") == 'en':
				languageTab = "en"
				t = gettext.translation('English', PROJECT_ABSOLUTE_PATH + "\\locale", languages=["en"])
				t.install()
			else:
				languageTab = "zh_CN"
				t = gettext.translation('Chinese', PROJECT_ABSOLUTE_PATH + "\\locale", languages=["zh_CN"])
				t.install()
				
	except:
		#print(languageTab)
		if languageTab == "zh_CN":
			t = gettext.translation('Chinese', 'locale', languages=["zh_CN"])
			t.install()
		elif languageTab == "en":
			t = gettext.translation('English', PROJECT_ABSOLUTE_PATH + "\\locale", languages=["en"])
			t.install()
		else:
			languageTab = "en"
			t = gettext.translation('English', PROJECT_ABSOLUTE_PATH + "\\locale", languages=["en"])
			t.install()


	# firs start version show
	if len(sys.argv) == 2 and sys.argv[1] == "update":
		if os.path.exists((os.getcwd()+"\\temp\\"+"QPYcom.exe")):
			app = wx.App()
			wx.MessageDialog(None, _(u"升级失败"), _(u"提示"), wx.OK).ShowModal()
		else:
			app = wx.App()
			wx.MessageDialog(None, _(u"升级成功"), _(u"提示"), wx.OK).ShowModal()
	else:
		pass


	def __init__(self):
		wx.App.__init__(self, redirect=False, filename=PROJECT_ABSOLUTE_PATH + "\\logs\\software\\run.log", useBestVisual=True, clearSigInt=True)
		# wx.App.__init__(self, redirect=True, filename='test%s.log'%datetime.datetime.now().strftime('%Y-%m-%d'), useBestVisual=True, clearSigInt=True)
		# wx.App.__init__(self, redirect=False, useBestVisual=True, clearSigInt=True)
		#self.locale = wx.Locale(wx.LANGUAGE_ENGLISH)
		#app.locale = wx.Locale(wx.LANGUAGE_CHINESE_SIMPLIFIED)
		if languageTab == "en":
			self.locale = wx.Locale(wx.LANGUAGE_DEFAULT)  # avoid PyAssertionErrors
	def OnInit(self):
		global q
		self.name = "SingleApp-%s".format(wx.GetUserId())
		# print(wx.GetUserId())
		self.instance = wx.SingleInstanceChecker(self.name)
		if self.instance.IsAnotherRunning():
			# wx.MessageBox(
			  # "An instance of the application is already running",
				# "Error",
				 # wx.OK | wx.ICON_WARNING
			# )
			wx.MessageDialog(None, _(u"请勿重复启动程序"), _(u"提示"), wx.OK).ShowModal()
			return False
		self.frame = qpyTools(None, wx.ID_ANY, "")
		self.SetTopWindow(self.frame)
		self.frame.Show()
		
		# thread: serialDet
		tSerialDet = serialDet()
		tSerialDet.setDaemon(True)	#set as deamon, stop thread while main frame exit
		tSerialDet.start()

		# thread: serialOperation
		tSerialOp = serialOperation()
		tSerialOp.setDaemon(True)	#set as deamon, stop thread while main frame exit
		tSerialOp.start()

		# thread: serialKeepStatus
		tSerialKpStatus = serialKeepStatus()
		tSerialKpStatus.setDaemon(True)  #set as deamon, stop thread while main frame exit
		tSerialKpStatus.start()
		
		# thread: statusQueue
		q = statusQueue()
		t1 = threading.Thread(target=q.queue_get, args=())
		t1.setDaemon(True)
		t1.start()

		repeat_update_check()  # Background check update
		# autoUpdataProgressBar()  # auto update process bar
		return True
# end of class mainFrame

if __name__ == "__main__":
	file_name = os.path.basename(sys.executable)
	qpyTools = mainFrame()
	qpyTools.MainLoop()
